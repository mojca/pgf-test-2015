% Copyright 2010 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Specifying Graphs}
\label{section-library-graphs}

\subsection{Overview}

\tikzname\ offers a powerful path command for specifying how the nodes
in a graph are connected by edges and arcs: The |graph| path
command, which becomes available when you load the |graph| library.

\begin{tikzlibrary}{graph}
  The package must be loaded to use the |graph| path command.
\end{tikzlibrary}


In this section, by \emph{graph} we refer to a set of nodes together
with some edges (sometimes also called arcs, in case they are
directed) such as the following:

\begin{codeexample}[]
\tikz \graph { a -> {b, c} -> d };  
\end{codeexample}

\begin{codeexample}[]
\tikz
  \graph [nodes={draw, circle}, clockwise, radius=.5cm, empty nodes, n=5]
  { I_n [name=inner] -- [bipartite] I_n [name=outer] };
\end{codeexample}

\begin{codeexample}[]
\tikz
  \graph [nodes={draw, circle}, clockwise, radius=.75cm, empty nodes, n=8]
  { C_n [name=inner] <-> [shorten <=1pt, shorten >=1pt] C_n [name=outer] };
\end{codeexample}

The nodes of a graph are normal \tikzname\ nodes, the edges are
normal lines drawn between nodes. There is nothing in the |graph|
library that you cannot do using the normal |\node| and the |edge|
command. Rather, its purpose is to offer a concise and powerful way of
\emph{specifying} which nodes are present 
and how they are connected. The |graph| library only offers simple
methods for specifying \emph{where} the nodes should be shown, its
main strength is in specifying which nodes and edges are present in 
principle. 

The |graph| library uses a syntax that is quite different from the
normal \tikzname\ syntax for specifying nodes. The reason for this is
that for many medium-sized graphs it can become quite cumbersome to
specify all the nodes using |\node| repeatedly and then using a great
number of |edge| command; possibly with complicated |\foreach|
statements. Instead, the syntax of the |graph| library is loosely
inspired by the \textsc{dot} format, which is quite useful for
specifying medium-sized graphs, with some extensions on top.



\subsection{Concepts}

The present section aims at giving a quick overview of the main
concepts behind the |graph| command. The exact syntax is explained in
more detail in later sections.


\subsubsection{Concept: Node Chains}

The basic way of specifying a graph is to write down a \emph{node
  chain} as in the following example: 

\begin{codeexample}[]
\tikz [every node/.style = draw]
  \graph { foo -> bar -> blub };  
\end{codeexample}

As can be seen, the text |foo -> bar -> my node| creates three nodes,
one with the text |foo|, one with |bar| and one with the text
|blub|. These nodes are connected by arrows, which are caused by
the |->| between the node texts. Such a sequence of node texts and
arrows between them is called a \emph{chain} in the following. 

Inside a graph there can be more than one chain:

\begin{codeexample}[]
\tikz \graph {
  a -> b -> c;
  d -> e -> f;
  g -> f;
};  
\end{codeexample}

Multiple chains are separated by a semicolon or a comma (both have
exactly the same effect). As the example shows, when a node text is
seen for the second time, instead of creating a new node, a connection
is created to the already existing node.

When a node like |f| is created, both the node name and the node text
are identical by default. This is not always desirable and can be
changed by using the |as| key:

\begin{codeexample}[]
\tikz \graph {
  x1 [as=$x_1$] -> x2 [as=$x_2$, red] -> x3 [as=$x_3$];
  x1 -> [bend left] x3;
};  
\end{codeexample}


\subsubsection{Concept: Chain Groups}

Multiple chains that are separated by a semicolon or a comma and that
are surrounded by curly braces form what will be called a \emph{chain
  group} or just a \emph{group}. A group in itself has no special
effect. However, things get interesting when you write down a node or
even a whole group and connect it to another group. In this case, the
``exit points'' of the first node or group get connected to the
``entry points'' of the second node or group:

\begin{codeexample}[]
\tikz \graph {
  a -> {
    b -> c,
    d -> e
  } -> f
};  
\end{codeexample}

Chain groups make it easy to create tree structures:

\begin{codeexample}[]
\tikz \graph [grow down, branch right=2.5cm] {
  root -> {
    child 1,
    child 2 -> {
      grand child 1,
      grand child 2
    },
    child 3 -> {
      grand child 3
    }
  }
};
\end{codeexample}

As can be seen, the placement is not particularly nice by default, but
may suffice in some situations.


\subsubsection{Concept: Node Sets}

When you write down some node text inside a |graph| command, a new
node is created by default unless this node has already been created
inside the same |graph| command. In particular, if a node has
already been declared outside of the current |graph| command, a new
node of the same name gets created.

This is not always the desired behaviour. Often, you may wish to make
nodes part of a graph than have already been defined prior to the use
of the |graph| command. For this, simply surround a node name by
parentheses. This will cause a reference to be created to an already
existing node:

\begin{codeexample}[]
\tikz {
  \node (a) at (0,0) {A};
  \node (b) at (1,0) {B};
  \node (c) at (2,0) {C};
  
  \graph { (a) -> (b) -> (c) };
}
\end{codeexample}

You can even go a step further: A whole collection of nodes can all be
flagged to belong to a \emph{node set} by adding the option
|set=|\meta{node set name}. Then, inside a |graph| command, you can
collectively refer to these nodes by surrounding the node set name in
parentheses: 

\begin{codeexample}[]
\tikz [new set=my nodes] {
  \node [set=my nodes, circle,    draw] at (1,1)   {A};
  \node [set=my nodes, rectangle, draw] at (1.5,0) {B};
  \node [set=my nodes, diamond,   draw] at (1,-1)  {C};
  \node (d)           [star,      draw] at (3,0)   {D};

  \graph { X -> (my nodes) -> (d) };
}
\end{codeexample}


\subsubsection{Concept: Graph Macros}

Often, a graph will consist -- at least in parts -- of standard
parts. For instance, a graph might contain a cycle of certain size or
a path or a clique. To facilitate specifying such graphs, you can
define a \emph{graph macro}. Once a graph macro has been defined, you
can use the name of the graph to make a copy of the graph part of the
graph currently being specified:

\begin{codeexample}[]
\tikz \graph { K_n [n=6, clockwise] };
\end{codeexample}

\begin{codeexample}[]
\tikz \graph { C_n [n=5, clockwise] -> mid };
\end{codeexample}

The library |graphs.standard| defines a number of such graphs,
including the complete clique $K_n$ on $n$ nodes, the complete
bipartite graph $K_{n,m}$ with shores sized $n$ and $m$, the cycle
$C_n$ on $n$ nodes, the path $P_n$ on $n$ nodes, and the independent
set $I_n$ on $n$ nodes.


\subsubsection{Concept: Graph Expressions and Color Classes}

When a graph is being constructed using the |graph| command, it is
constructed recursively by uniting smaller graphs to larger
graphs. During this recursive union process the nodes
of the graph get implicitly \emph{colored} (conceptually) and you can
also explicitly assign colors to individual nodes and even change the
colors as the graph is being specified. All nodes having the same
color form what is called a \emph{color class}.

The power of color class is that special \emph{connector operators}
allow you to add edges between nodes having certain colors. For instance,
saying |clique=red| at the beginning of a group will
cause all nodes that have been flagged as being (conceptually) ``red''
to be connected as a clique. Similarly, saying
|bipartite={red}{green}| will cause edges to be added
between all red and all green nodes. More advanced connectors, like
the |butterfly| connector, allow you to add edges between color
classes in a fancy manner.

\begin{codeexample}[]
\tikz [x=8mm, y=6mm, font=\footnotesize, circle]
  \graph [nodes={fill=blue!70, text=white}, empty nodes, n=8] {
    I_n [name=A] --[butterfly={level=4}]
    I_n [name=B] --[butterfly={level=2}]
    I_n [name=C] --[butterfly]
    I_n [name=D] -- 
    I_n [name=E]  
  };
\end{codeexample}



\subsection{Syntax of the Graph Path Command}

\subsubsection{The Graph Command}

In order to construct a graph, you should use the |graph| path
command, which can be used anywhere on a path at any place where
you could also use a command like, say, |plot| or |--|.

\begin{command}{\graph}
  Inside a |{tikzpicture}| this is an abbreviation for |\path graph|.
\end{command}

\begin{pathoperation}{graph}{\opt{\oarg{options}}\meta{group specification}}
  When this command is encountered on a path, the construction of the
  current path is suspended (similarly to an |edge| command or a
  |node| command). In a local scope, the \meta{options} are first
  executed with the key path |/tikz/graphs|. Apart from the keys
  explained in the following, further premissible keys will
  be listed during the course of the rest of this section.

  \begin{stylekey}{/tikz/graphs/every graph}
    This style is executed at the beginning of every |graph| path
    command prior to the \meta{options}.
  \end{stylekey}

  Once the scope has been set up and once the \meta{options} have been
  executed, a parser starts to parse the \meta{group
    specification}. The exact syntax of such a group specification
  in explained in detail in
  Section~\ref{section-library-graphs-group-spec}. Basically, a group
  specification is a list of chain specifications, separated by commas
  or semicolons.

  Depending on the content of the \meta{group specification}, two
  things will happen:
  \begin{enumerate}
  \item A number of new nodes may be created. These will be inserted
    into the picture in the same order as if they had been created
    using multiple |node| path commands at the place where the |graph|
    path command was used. In other words, all nodes created in a
    |graph| path command will be painted on top of any nodes created
    earlier in the path and behind any nodes created later in the
    path. Like normal nodes, the newly created nodes always lie on top
    of the path that is currently being created (which is often
    empty, for instance when the |\graph| command is used).
  \item Edges between the nodes may be added. They are added in the
    same order as if the |edge| command had been used at the position
    where the |graph| command is being used.
  \end{enumerate}

  Let us now have a look at some common keys that may be used inside
  the \meta{options}:
  \begin{key}{/tikz/graphs/nodes=\meta{options}}
    This option causes the \meta{options} to be applied to each newly
    created node inside the \meta{group specification}.
    \begin{codeexample}[]
\tikz \graph [nodes=red] { a -> b -> c };      
    \end{codeexample}
    Multiple uses of this key accumulate.
  \end{key}
  \begin{key}{/tikz/graphs/edges=\meta{options}}
    This option causes the \meta{options} to be applied to each newly
    created edge inside the \meta{group specification}.
    \begin{codeexample}[]
\tikz \graph [edges={red,thick}] { a -> b -> c };      
    \end{codeexample}
    Again, multiple uses of this key accumulate.
  \end{key}
  \begin{key}{/tikz/graphs/edge=\meta{options}}
    This is an alias for |edges|.
  \end{key}
  
  \begin{key}{/tikz/graphs/edge node=\meta{node specification}}
    This key specifies that the \meta{node specification} should be
    added to each newly created edge as an implicitly placed node. 
    \begin{codeexample}[]
\tikz \graph [edge node={node [red, near end] {X}}] { a -> b -> c };      
    \end{codeexample}
    Again, multiple uses of this key accumulate.
    \begin{codeexample}[]
\tikz \graph [edge node={node [near end] {X}},
              edge node={node [near start] {Y}}] { a -> b -> c };      
    \end{codeexample}
  \end{key}
  
  \begin{key}{/tikz/graphs/edge label=\meta{text}}
    This key is an abbreviation for
    |edge node=node[auto]{|\meta{text}|}|. The net effect is that the
    |text| is placed next to the newly created edges.
    \begin{codeexample}[]
\tikz \graph [edge label=x] { a -> b -> {c,d} };      
    \end{codeexample}
  \end{key}
  
  \begin{key}{/tikz/graphs/edge label'=\meta{text}}
    This key is an abbreviation for
    |edge node=node[auto,swap]{|\meta{text}|}|. 
    \begin{codeexample}[]
\tikz \graph [edge label=out, edge label'=in] { C_n [clockwise, n=5] };      
    \end{codeexample}
  \end{key}  
\end{pathoperation}


\subsubsection{Syntax of Group Specifications}
\label{section-library-graphs-group-spec}

A \meta{group specification} inside a |graph| path command has the
following syntax:
\begin{quote}
  |{|\opt{\oarg{options}}\meta{list of chain specifications}|}|
\end{quote}
The \meta{chain specifications} must contain chain specifications,
whose syntax is detailed in the next section, separated by either
commas or semicolons; you can freely mix them.
It is permissible to use empty lines (which are mapped to |\par|
commands internally) to structure the chains visually, they are simply
ignored by the parser. 

In the following example, the group specification consists of three
chain specifications, namely of |a -> b|, then |c| alone, and finally
|d -> e -> f|:
\begin{codeexample}[]
\tikz \graph {
  a -> b,
  c;

  d -> e -> f
};
\end{codeexample}
The above has the same effect as the more compact group specification
|{a->b,c,d->e->f}|.

Commas are used to detect where chain specifications end. However, you
will often wish to use a comma also inside the options of a single
node like in the following example:

\begin{codeexample}[]
\tikz \graph {
  a [red, draw] -> b [blue, draw],
  c [brown, draw, circle]
};
\end{codeexample}

Note that the above example works as expected: The first comma inside
the option list of |a| is \emph{not} interpreted as the end of the
chain specification ``|a [red|''. Rather, commas inside square
brackets are ``protected'' against being interpreted as separators of
group specifications.


The \meta{options} that can be given at the beginning of a group
specification are local to the group. They are executed with the path
prefix |/tikz/graphs|. Note that for the outermost group specification
of a graph it makes no difference whether the options are passed to
the |graph| command or whether they are given at the beginning of this
group. However, for groups nested inside other groups, it does make a
difference:

\begin{codeexample}[]
\tikz \graph {
  a -> { [nodes=red] % the option is local to these nodes:
    b, c
  } ->
  d
};
\end{codeexample}

There is special support for the |\foreach| statement inside groups:
You may use the statement inside a group
specification at any place where a \meta{chain specification} would
normally go. In this case, the |\foreach| statement is executed and
for each iteration the content of the statement's body is treated and
parsed as a new chain specification.

\begin{codeexample}[]
\tikz \graph [math nodes, branch down=5mm] {
  a -> { 
    \foreach \i in {1,2,3} {
      a_\i -> { x_\i, y_\i }
    },
    b
  }
};
\end{codeexample}


\subsubsection{Syntax of Chain Specifications}

A \meta{chain specification} has the following syntax: It consists of
a sequence of \meta{node specifications}, where subsequent node 
specifications are separated by \meta{edge specifications}. Node
specifications, which typically consist of some text, are discussed in
the next section in more detail. They normally represent a single node
that is either newly created or exists already, but they may also
specify a whole set of nodes.

An \meta{edge specification} specifies \emph{which} of the node(s) to
the left of the edge specification should be connected to which
node(s) to the right of it and it also specifies in which direction
the connections go. In the following, we only discuss how the
direction is chosen, the powerful mechanism behind choosing which
nodes should be connect is detailed in 
Section~\ref{section-library-graphs-color-classes}.

The syntax of an edge specification is always one of the following
five possibilities: 

\begin{quote}
  |->| \opt{\oarg{options}}\\
  |--| \opt{\oarg{options}}\\
  |<-| \opt{\oarg{options}}\\
  |<->| \opt{\oarg{options}}\\
  |-!-| \opt{\oarg{options}}
\end{quote}

The first four correspond to a directed edge, an undirected edge, a
``backward'' directed edge, and a bidirected edge, respectively. The
fifth edge specification means that there should be no edge (this
specification can be used together with the |simple| option to remove
edges that have previously been added, see
Section~\ref{section-library-graphs-simple}). 

Suppose the nodes \meta{left nodes} are to the left of the \meta{edge
  specification} and \meta{right nodes} are to the right and suppose
we have written |->| between them. Then the following happens:
\begin{enumerate}
\item The \meta{options} are executed (inside a local scope) with the
  path |/tikz/graphs|.  These options may setup the connector algorithm
  (see below) and may also use keys like |edge| or |edge label| to
  specify how the edge should look like. As a convenience, whenever an
  unknown key is encountered for the path |/tikz/graphs|, the key is
  passed to the |edge| key. This means that you can directly use
  options like |thick| or |red| inside the \meta{options} and they
  will apply to the edge as expected.
\item The chosen connector algorithm, see 
  Section~\ref{section-library-graphs-color-classes}, is used to
  compute from which of the \meta{left nodes} an edge should lead to
  which of the \meta{right nodes}. Suppose that $(l_1,r_1)$, \dots,
  $(l_n,r_n)$ is the list of node pairs that result (so there should
  be an edge between $l_1$ and $r_1$ and another edge between $l_2$
  and $r_2$ and so on).
\item For each pair $(l_i,r_i)$ an edge is created. This is done by
  calling the following key (for the edge specification |->|, other
  keys are executed for the other kinds of specifications):
  \begin{key}{/tikz/graphs/new ->=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    This key will be called for a |->| edge specification with the
    following four parameters: 
    \begin{enumerate}
    \item \meta{left node} is the name of the ``left'' node, that is,
      the name of $l_i$.
    \item \meta{right node} is the name of the right node.
    \item \meta{edge options} are the accumulated options from all
      calls of |/tikz/graph/edges| in groups that surround the edge
      specification.
    \item \meta{edge nodes} is text like |node {A} node {B}| that
      specifies some nodes that should be put as labels on the edge
      using \tikzname's implicit positioning mechanism.
    \end{enumerate}
    By default, the key executes the following code:
    \begin{quote}
      |\path [draw,->,|\meta{edge options}|]|\\
      \hbox{}\quad|(|\meta{left
        node}|\tikzgraphleftanchor) to |\meta{edge
        nodes}||\\
      \hbox{}\quad|(|\meta{right node}|\tikzgraphrightanchor);|
    \end{quote}
    You are welcome to change the code underlying the key.
  \end{key}
  \begin{key}{/tikz/graphs/left anchor=\meta{anchor}}
    This anchor is used for the node that is to the left of an edge
    specification. Setting this anchor to the empty string means that
    no special anchor is used (which is the default). The
    \meta{anchor} is stored in the macro |\tikzgraphleftanchor| with a
    leading dot.
    \begin{codeexample}[]
\tikz \graph {
  {a,b,c} -> [bipartite] {e,f,g}
};
    \end{codeexample}
    \begin{codeexample}[]
\tikz \graph [left anchor=east, right anchor=west] {
  {a,b,c} -- [bipartite] {e,f,g}
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/right anchor=\meta{anchor}}
    Works like |left anchor|, only for |\tikzgraphrightanchor|.
  \end{key}
  For the other three kinds of edge specifications, the following keys
  will be called:
  \begin{key}{/tikz/graphs/new --=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    This key is called for |--| with the same parameters as above. The
    only difference in the definition is that in the |\path| command
    the |->| gets replaced by |-|.
  \end{key}
  \begin{key}{/tikz/graphs/new <->=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |<->| with the same parameters as above. The |->| is
    replaced by |<-|
  \end{key}
  \begin{key}{/tikz/graphs/new <-=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |<-| with the same parameters as above. This will call
    |new ->| with the first two arguments exchanged.%
    \footnote{You might
      wonder why this key is needed: It seems more logical at first
      sight to just call |new edge directed| with swapped first
      parameters. Indeed, the default implementation of this key is to
      call |new edge directed| in such a way. However, a positioning
      algorithm might wish to take the fact that an edge is
      ``backward'' rater than ``forward'' into account in order to
      improve the layout.}
  \end{key}
  \begin{key}{/tikz/graphs/new -!-=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |-!-| with the same parameters as above. Does nothing
    by default.
  \end{key}
\end{enumerate}

Here is an example that shows the default rendering of the different
edge specifications:

\begin{codeexample}[]
\tikz \graph {
  a -> b;
  c -- d;
  e <- f;
  g <-> h
};  
\end{codeexample}


\subsubsection{Syntax of Node Specifications}

\label{section-library-graphs-node-spec}

Node specifications are the basic building blocks of a graph
specification. There are three different possible kinds of node
specifications, each of which has a different syntax: 

\begin{description}
\item[Direct Node Specification] \meta{node name} \opt{\oarg{options}}
\item[Reference Node Specification] |(|\meta{node name or node set name}|)|
\item[Group Node Specification] \meta{group specification}
\end{description}

The rule for determining which of the three possible kinds is meant is
as follows: If the node specification starts with an opening
parenthesis, a reference node specification is meant; if it starts
with an opening curly brace, a group specification is meant; and in
all other cases a direct node specification is meant.

\medskip
\textbf{Direct Node Specifications.} If after reading the first symbol
of a node specification is has been detected to be \emph{direct},
\tikzname\ will collect all text up to the next edge
specification and store it as the \meta{node name}. Due to the way the
parsing works and due to the restrictions on node names, the following
characters are forbidding inside the \meta{node name}: Commas,
semicolons, hyphens, braces, dots, parentheses, and
presumably some more. So, it is best to avoid special characters
inside the \meta{node name}; but the following characters \emph{are}
definitely allowed: spaces, underscores, the hat character.

Once the node name has been determined, it is checked whether the same
node name was already used inside the current graph. If this is the
case, then we say that the already existing node is \emph{referenced};
otherwise we say that the node is \emph{fresh}.

\begin{codeexample}[]
\tikz \graph {
  a -> b; % both are fresh
  c -> a; % only c is fresh, a is referenced
};
\end{codeexample}

This behaviour of
deciding whether a node is fresh or referenced can, however, be
modified by using the following key:
\begin{key}{/tikz/graphs/use existing node=\opt{\meta{true or
        false}} (default true)}
  When this key is set to |true|, all nodes will be considered to the
  referenced, no node will be fresh. This option is useful if you have
  already created all the nodes of a graph prior to using the |graph|
  command and you now only wish to connect the nodes.
\end{key}

When a fresh node has been detected, a new node is created in the
inside a protecting scope. For this, the current
placement strategy is asked to compute a default position for the
node, see Section~\ref{section-library-graphs-placement} for
details. Then, the command
\begin{quote}
  |\node (|\meta{node name}|) [|\meta{node options}|] {|\meta{text}|};|
\end{quote}
is called. The different parameters are as follows:
\begin{itemize}
\item
  The \meta{node name} is normally the node name that has been
  determined as described before. However, there is one exception: If
  the node name is just an underscore, then a fresh internal node name
  is created that is guaranteed to be different from all node names
  used in this or any other graph. Thus, an underscore represents an
  anonymous fresh node.
\item 
  The \meta{node options} are
  \begin{enumerate}
  \item The options that have accumulated in calls to |nodes| from
    the surrounding scopes.
  \item The local \meta{options}.
  \end{enumerate}
  The options are executed with the path prefix |/tikz/graphs|, but
  any unknown key is executed with the prefix |/tikz|. This means, in
  essence, that some esoteric keys are more difficult to use inside
  the options and that any key with the prefix |/tikz/graphs| will
  take precedence over a key with the prefix |/tikz|).
\item The \meta{text} that is passed to the |\node| command is
  computed as follows: First, you can use the following key to
  directly set the \meta{text}: 
  \begin{key}{/tikz/graphs/as=\meta{text}}
    The \meta{text} is used as the text of the node. This allows you
    to provide a text for the node that differs arbitrarily from the
    name of the node.
    \begin{codeexample}[]
\tikz \graph { a [as=$x$] -- b [as=$y_5$] -> c [red, as={a--b}] };
    \end{codeexample}
  \end{key}
  This key always takes precedence over all of the mechanisms
  described below. In case the |as| key is not used, a default text
  is chosen as follows: The current value of the following key is used as
  \meta{text}:
  \begin{key}{/tikz/graphs/typeset=\meta{code}}
    The macro or code stored in this key is used as the
    \meta{text} if the node. Inside the \meta{code}, the following
    macros are available:
    \begin{command}{\tikzgraphnodetext}
      This macro expands to the \meta{node name}, except for
      anonymous fresh nodes, where it expands to the empty string.
    \end{command}
    \begin{command}{\tikzgraphnodepath}
      This macro expands to the current path of the node. These
      paths result from the use of graph macros, see
      Section~\ref{section-library-graphs-macros}.
    \end{command}
    \begin{command}{\tikzgraphnodefullname}
      This macro contains the concatenation of the above two.
    \end{command}
  \end{key}
  By default, the typesetter is just set to |\tikzgraphnodetext|,
  which means that the default text of a node is its name. However,
  it may be useful to change this: For instance, you might wish that
  the text of all graph nodes is, say, surrounded by parentheses:
  \begin{codeexample}[]
\tikz \graph [typeset=(\tikzgraphnodetext)]
  { a -> b -> c };
  \end{codeexample}
  A more advanced macro might take apart the node text and render it
  differently: 
  \begin{codeexample}[]
\def\mytypesetter{\expandafter\myparser\tikzgraphnodetext\relax}
\def\myparser#1 #2 #3\relax{%
  $#1_{#2,\dots,#3}$
}
\tikz \graph [typeset=\mytypesetter, grow down]
  { a 1 n -> b 2 m -> c 4 nm };
  \end{codeexample}
  The following styles install useful predefined typesetting macros:
  \begin{key}{/tikz/graphs/empty nodes}
    Just sets |typeset| to nothing, which causes all nodes to have an
    empty text (unless, of course, the |as| option is used):
    \begin{codeexample}[]
\tikz \graph [empty nodes, nodes={circle, draw}] { a -> {b, c} };  
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/math nodes}
    Sets |typeset| to |$\tikzgraphnodetext$|, which causes all nodes
    names to be typeset in math mode:
    \begin{codeexample}[]
\tikz \graph [math nodes, nodes={circle, draw}] { a_1 -> {b^2, c_3^n} };  
    \end{codeexample}
  \end{key}
\end{itemize}

If a node is referenced instead of fresh, then this node becomes the
node that will be connected by the preceding or following edge
specification to other 
nodes. The \meta{options} are executed even for a referenced node, but
they cannot be used to change the appearance of the node (because the
node exists already). Rather, the \meta{options} can only be used to
change the logical coloring of the node, see
Section~\ref{section-library-graphs-color-classes} for details.

\medskip
\textbf{Reference Node Specifications.} A reference node specification
is a node specification that starts with an opening parenthesis. In
this case, parentheses must surround a \meta{name} as in |(foo)|,
where |foo| is the \meta{name}. The following will now happen:

\begin{enumerate}
\item It is tested whether \meta{name} is the name of a currently
  active \emph{node set}. This case will be discussed in a moment.
\item Otherwise, the \meta{name} is interpreted and treated as a
  referenced node, but independently of whether the node has already
  been fresh in the current graph or not. In other words, the node
  must have been defined either already inside the graph (in which
  case the parenthesis are more or less superfluous) or it must have
  been defined outside the current picture.

  The way the referenced node is handled is the same way as for a
  direct node that is a referenced node.

  If the node does not already exist, an error message is printed.
\end{enumerate}

Let us now have a look at node sets. Inside a |{tikzpicture}| you can
locally define a \emph{node set} by using the following key:
\begin{key}{/tikz/new set=\meta{set name}}
  This will setup a node set named \meta{set name} within the current
  scope. Inside the scope, you can add nodes to the node set using the
  |set| key. If a node set of the same name already exists in the
  current scope, it will be reset and made empty for the current
  scope.

  Note that this command has the path |/tikz| and is normally used
  \emph{outside} the |graph| command.
\end{key}
\begin{key}{/tikz/set=\meta{set name}}
  This key can be used as an option with a |node| command. The
  \meta{set name} must be the name of a node set that has previously
  been created inside some enclosing scope via the |new set| key. The
  effect is that the current node is added to the node set.
\end{key}

When you use a |graph| command inside a scope where some node set
called \meta{set name} is defined, then inside this |graph| command
you use |(|\meta{set name}|)| to reference \emph{all} of the nodes in
the node set. The effect is the same as if instead of the reference to
the set name you had created a group specification containing a list
of references to all the nodes that are part of the node set.

\begin{codeexample}[]
\begin{tikzpicture}[new set=red, new set=green, shorten >=2pt]
  \foreach \i in {1,2,3} {
    \node [draw, red!80,         set=red]   (r\i) at (\i,1) {$r_\i$};
    \node [draw, green!50!black, set=green] (g\i) at (\i,2) {$g_\i$};
  }
  \graph {
    root [xshift=2cm] ->
    (red)             -> [bipartite, right anchor=south]
    (green)
  };
\end{tikzpicture}
\end{codeexample}

There is an interesting caveat with referencing node sets: Suppose
that at the beginning of a graph you just say |(foo);| where |foo| is
a set name. Unless you have specified special options, this will cause
the following to happen: A group is created whose members are all the
nodes of the node set |foo|. These nodes become referenced nodes, but
otherwise nothing happens since, by default, the nodes of a group are
not connected automatically. However, the referenced nodes have now
been referenced inside the graph, you can thus subsequently access
them as if they had been defined inside the graph. Here is an example
showing how you can create nodes outside a |graph| command and then
connect them inside as if they had been declared inside:

\begin{codeexample}[]
\begin{tikzpicture}[new set=import nodes]
  \begin{scope}[nodes={set=import nodes}] % make all nodes part of this set
    \node [red] (a) at (0,1) {$a$};
    \node [red] (b) at (1,1) {$b$};
    \node [red] (d) at (2,1) {$d$};
  \end{scope}

  \graph {
    (import nodes);         % "import" the nodes

    a -> b -> c -> d -> e;  % only c and e are new
  };
\end{tikzpicture}
\end{codeexample}


\medskip
\textbf{Group Node Specifications.}
At a place where a node specification should go, you can also instead
provide a group specification. Since nodes specifications are part of
chain specifications, which in turn are part of group specifications,
this is a recursive definition.

\begin{codeexample}[]
\tikz \graph { a -> {b,c,d} -> {e -> {f,g}, h} };
\end{codeexample}

As can be seen in the above example, when two groups of nodes are
connected via an edge specification, it is not immediately obvious
which connecting edges are added. This is detailed in
Section~\ref{section-library-graphs-color-classes}. 

\subsection{Simple Versus Multi-Graphs}

\label{section-library-graphs-simple}

The |graph| library allows you to construct both simple graphs and
multi-graphs. In a simple graph there can be at most one edge between
any two vertices, while in a multi-graph there can be multiple edges
(hence the name). The two keys |multi| and |simple| allow you to
switch (even locally inside on of the graph's scopes) between which
kind of graph is being constructed. By default, the |graph| command
produces a multi-graph since these are faster to construct.

\begin{key}{/tikz/graphs/multi}
  When this edge is set for a whole graph (which is the default) or
  just for a group (which is useful if the whole graph is simple in
  general, but a part is a multi-graph), then when you specify an edge
  between two nodes several times, several such edges get created:

\begin{codeexample}[]
\tikz \graph [multi] { % "multi" is not really necessary here
  a ->[bend left,  red]  b;
  a ->[bend right, blue] b;
};
\end{codeexample}
  In case |multi| is used for a scope inside a larger scope where the
  |simple| option is specified, then inside the local |multi| scope
  edges are immediately created and they are completely ignored when
  it comes to deciding which kind of edges should be present in the
  surrounding simple graph. From the surrounding scope's point of view
  it is as if the local |multi| graph contained no edges at all.

  This means, in particular, that you can use the |multi| option with
  a single edge to ``enforce'' this edge to be present in a simple
  graph. 
\end{key}

\begin{key}{/tikz/graphs/simple}
  In contrast a multi-graph, in a simple graph, at most one edge gets
  created for every pair of vertices:
\begin{codeexample}[]
\tikz \graph [simple]{
  a ->[bend left,  red]  b;
  a ->[bend right, blue] b;
};
\end{codeexample}
  As can be seen, the second edge ``wins'' over the first edge. The
  general rule is as follows: In a simple graph, whenever an edge
  between two vertices is specified multiple times, only the very last
  specification and its options will actually be executed.
  
  The real power of the |simple| option lies in the fact that you can
  first create complicated graph and then later redirect and otherwise
  modify edges easily: 

\begin{codeexample}[]
\tikz \graph [simple, grow right=2cm] {
  {a,b,c,d} ->[bipartite] {e,f,g,h};

  { [edges={red,thick}] a -> e -> d -> g -> a };
};
\end{codeexample}

  One particularly interesting kind of edge specification for a simple
  graph is |-!-|. Recall that this is used to indicate that ``no
  edge'' should be added between certain nodes. In a multi-graph, this
  key usually has no effect (unless the key |new -!-| has been
  redefined) and is pretty superfluous. In a simple graph, however, it
  counts as an edge kind and you can thus use it to remove an edge
  that been added previously:

\begin{codeexample}[]
\tikz \graph [simple] {
  K_n [n=8, clockwise];
  % Get rid of the following edges:
  1 -!- 2;
  3 -!- 4;
  6 -!- 8;
  % And make one edge red:
  1 --[red] 3;
};
\end{codeexample}

  Creating a graph such as the above in other fashions is pretty
  awkward.

  For every unordered pair $\{u,v\}$ of vertices at most one edge will
  be created in a simple graph. In particular, when you say |a -> b|
  and later also |a <- b|, then only the edge |a <- b| will be
  created. Similarly, when you say |a -> b| and later |b -> a|, then
  only the edge |b -> a| will be created. 

  The power of the |simple| command comes at a certain cost: As the
  graph is being constructed, a (sparse) array is created that keeps
  track for each edge of the last edge being specified. Then, at the
  end of the scope containing the |simple| command, for every pair of
  vertices the edge is created. This is implemented by two nested
  loops iterating over all possible pairs of vertices -- which may
  take quite a while in a graph of, say, 1000 vertices.
  Internally, the |simple| command is implemented as an operator that
  adds the edges when it is called, but
  this should be unimportant in normal situations.
\end{key}



\subsection{Graph Operators, Color Classes, and Graph Expressions}
\label{section-library-graphs-color-classes}

\tikzname's |graph| command employs a powerful mechanism for
adding edges between nodes and sets of nodes. To a graph theorist,
this mechanism may be known as a \emph{graph expression}: A graph is
specified by starting with small graphs and then applying
\emph{operators} to them that form larger graphs and that connect and
recolor colored subsets of the graph's node in different ways. 

In the following, the basic use of these operators is explained
first. For most readers it will suffice to read only this part. Later
sections explain the theory that is behind graph expressions.


\subsubsection{Operators in a Nutshell}

The most common use of operators is to connect the nodes of two 
groups. As explained in
Section~\ref{section-library-graphs-node-spec}, you can form a group 
of nodes by surrounding them by curly braces and you can then
\emph{connect} them by putting on of the four possible edge
specification |--|, |<-|, |->|, or |<->| between them. 

Section~\ref{section-library-graphs-node-spec} explained in detail,
how you can configure the appearance of an edge created using the edge
specification, but left it open, which nodes should be connected. If
there are just a single left node and a single right node, the
situation is pretty obvious, but if there are whole groups of nodes to
the left and the right of an edge specification, the situation is more
complex.

What happens is the following: Whenever two sets of nodes need to be
connected by edges, a \emph{connection operator} or just
\emph{connector} is applied. This is, essentially, an algorithm that
gets two lists of nodes and must then produce a list of edges between
them. The two most important join connectors are the following:
\begin{description}
\item[Bipartite] The |bipartite| connector simply adds edges
  between \emph{all} nodes of the sets:
  \begin{codeexample}[]
\tikz \graph { {a, b}       ->[bipartite]  {c, d, e} --[bipartite]
               {g, h, i, j} --[bipartite]  k };    
  \end{codeexample}
\item[Matching] The |matching| connector forms a maximum
  \emph{matching} between the nodes of the two sets. The first node of
  the first set is connected to the first node of 
  the second set, the second node of the first set is connected to the
  second node of the second set, and so on. If the sets have the same
  size, what results is what graph theoreticians call a \emph{perfect
    matching}, otherwise only a maximum, but not perfect matching
  results. 
  \begin{codeexample}[]
\tikz \graph { {a, b, c} ->[matching] {d, e, f} --[matching]
               {g, h}    --[matching] {i, j, k} };    
  \end{codeexample}
\item[Flow] The |flow| connector works like the |matching|
  connector, only it behaves differently when the two to-be-connected
  sets have different size. In this case, all the surplus nodes get
  connected to the last node of the other set. This simple rule allows
  for some powerful effects (since this connector is the default,
  there is no need to add it here):
  \begin{codeexample}[]
\tikz \graph { a -> {b, c} -> {d, e} -- f};    
  \end{codeexample}
  The |flow| connector also makes it easy to create trees and
  series-parallel graphs.
\end{description}

You can set the to-be-used connector both globally as well as
locally:

\begin{codeexample}[]
\tikz \graph [default edge operator=matching] {
  {a, b}    ->[flow]
  {c, d, e} --[bipartite]
  {f, g, h} -- 
  {i, j, k}
};    
\end{codeexample}



\subsubsection{Advanced: Color Classes}

\label{section-library-graph-coloring}

\tikzname\ keeps track of a \emph{(multi)coloring} of the graph as it
is being constructed. This does not mean that the 
actual color of the nodes on the page will be different, rather, in
the following we refer to ``logical'' colors in the way graph
theoreticians do. These ``logical'' colors are only important while
the graph is being constructed and they are ``thrown away'' at the end
of the construction. The actual (``physical'') colors of the nodes are
set independently of these logical colors.

As a graph is being constructed, each node can be part of one or more
overlapping \emph{color classes}. So, unlike what is sometimes called a
\emph{legal coloring}, the logical colorings that \tikzname\ keeps
track of may assign multiple colors to the same node and two nodes
connected by an edge may well have the same color.

Color classes must be declared prior to use. This is done using the
following key:
\begin{key}{/tikz/graphs/color class=\meta{color class name}}
  This sets up a new color class called \meta{color class name}. Nodes
  and whole groups of nodes can now be colored with \meta{color class
    name}. This is done using the following keys, which become
  available inside the current scope: 
  \begin{key}{/tikz/graphs/\meta{color class name}}
    This key internally uses the |operator| command to setup an
    operator that will cause all nodes of the current group to get the
    ``logical color'' \meta{color class name}. Nodes retain this color
    in all encompassing scopes, unless it is explicitly changed (see
    below) or unset (again, see below).
    \begin{codeexample}[]
\tikz \graph [color class=red] {
  [cycle=red]  % causes all "logically" red nodes to be connected in
               % a cycle
  a,
  b [red],
  { [red] c ->[bend right] d },
  e
};
    \end{codeexample}
    \begin{codeexample}[]
\tikz \graph [color class=red, color class=green, math nodes, clockwise, n=5] {
  [bipartite={red}{green}]
  { [red]   r_1, r_2 },
  { [green] g_1, g_2, g_3 }
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/not \meta{color class name}}
    Sets up an operator for the current scope so that all nodes in it
    loose the color \meta{color class name}. You can also use
    |!|\meta{color class name} as an alias for this key.
    \begin{codeexample}[]
\tikz \graph [color class=red, color class=green, math nodes, clockwise, n=5] {
  [bipartite={red}{green}]
  { [red]   r_1, r_2 },
  { [green] g_1, g_2, g_3 },
  g_2 [not green]
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/recolor \meta{color class name} by=\meta{new color}}
    Causes all keys having color \meta{color class name} to get
    \meta{new color} instead. They loose having color \meta{color
      class name}, but other colors are not affected.
  \end{key}  
\end{key}




\subsubsection{Advanced: Semantics of Graph Specifications}

\label{section-library-graphs-semantics}

Let us now have at the semantics of graph specifications. For this,
let me start with some concepts from graph theory that will help in
describing how the |graph| library works. 

The graphs that the |graph| library handles are ``multi-colored
multi-graphs.'' This means a graph consists of a set~$V$ of vertices,
a multi-set $E \subseteq V \times V$ of edges, and each color $C$ is
modeled as a subset $C \subseteq V$ of colors. Note that a graph node
can have several different colors at the same time; you may also think
of the colors as predicates.

A \emph{graph expression} is a term $t$ over a certain set of
operators and atomic expressions. Every such term \emph{evaluates} to
a certain graph~$G$, and we write $G(t)$ for the graph that $t$
evaluates to. Now, first, $\iota(x)$ is an atomic expression, where
$x$ is a name for a node. Then $G(\iota(x))$ is the graph consisting
of the single node~$x$ with no colors. Second, let $X$ be an $n$-ary
function that takes $n$ graphs (multi-colored multi-graphs to be precise)
and yields a new graph (again a multi-colored multi-graph). Then for
$n$ graph expressions $t_1$ to $t_n$, let $\kappa_X(t_1,\dots,t_n)$ also be
a graph expression. It evaluated as following:
$G\bigl(\kappa_X(t_1,\dots,t_n)\bigr) = X\bigl(G(t_1),\dots, G(t_n)\bigr)$.

As the |graph| command parses the \meta{group specification}, it
builds a graph expression internally and the following table describes
in detail how each syntactic specification is mapped to a certain
graph expression. The graph (in particular, the edged) that are then
created is exactly the graph that the graph expression evaluates to.

\begin{description}
\item[Direct node specification] The syntactic construct
  \meta{text}|[|\meta{options}|]| that corresponds to what was earlier
  called a \emph{direct} node specification corresponds to the 
  graph expression
  $\kappa_{\mathit{colorize}_{\mathtt{all},\mathtt{source},\mathtt{target}}}
  (\iota(\meta{text}))$. Here, $\mathit{colorize}_C$ is a function
  that takes a graph as input and (additionally) colors all nodes with
  the colors in~$C$.

  The \meta{options} are largely ignored, except if the
  |operator=|\meta{op} key is used inside. In this case, 
  \begin{quote}
    \meta{text}|[|\meta{more options}|,operator=|\meta{$op_1$}%
    |, operator=|\meta{$op_2$}%
    |, |\dots|, operator=|\meta{$op_n$}|]|
  \end{quote}
  is mapped to the graph expression 
  $$\kappa_{\meta{$op_n$}}\bigl(\dots\bigr(\kappa_{\meta{$op_1$}}(
  \kappa_{\mathit{colorize}_{\mathtt{all},\mathtt{source},\mathtt{target}}}(\iota(\meta{text}))\bigr)\dots\bigr)$$.  
\item[Group specifications] The syntactic construct
  \begin{quote}
    |{[|\meta{more
        options}|, operator=|\meta{$op_1$}|, |\dots|, operator=|\meta{$op_n$}|] |
      \meta{$A_1$}|, |\dots|, |\meta{$A_m$}|}|
  \end{quote}
  is handled as follows: Let $t_1$ to $t_m$ be the graph expressions
  corresponding to $A_1$ to $A_m$. Then the resulting graph expression
  is 
  $$\kappa_{\meta{$op_n$}}\bigl(\dots\bigr(\kappa_{\meta{$op_1$}}(\kappa_\cup(t_1,\dots,t_m)\bigr)\dots\bigr).$$ 
\item [Chain specifications]
  The syntactic construct
  \begin{quote}
    \meta{A} \meta{edge specification}|[|\meta{more
      options}|, operator=|\meta{$op_1$}|, |\dots|, operator=|\meta{$op_n$}|]|
    \meta{B}
  \end{quote}
  is handled as follows: Let $t$ and $t'$ be the graph expressions
  corresponding to \meta{A} and \meta{B}. Then the resulting graph
  expression is
  $$\kappa_Y\bigl(\kappa_{\meta{$op_n$}}\bigl(\dots\bigr(\kappa_{\meta{$op_1$}}(\kappa_X(t,t')\bigr)\dots\bigr)\bigr).$$
  Here, the operations $X$ and $Y$ work as follows:

  The function $X$ takes two graphs $G$ and $H$ as input. Then in $G$, a
  \emph{recoloring} is performed, which means that all nodes that used
  to have a certain color get a new color instead (if they has
  additional colors, these remain unchanged). In the graph $G$, all
  nodes that used to be colored |target| get colored |target'|. In the
  graph $H$, all nodes that used to be colored |source| get colored
  |source'| instead. Then, the two graphs are united.

  The function $Y$ takes a graph and simple removes the colors
  |source'| and |target'|.

  The net effect of all of the above is that the operators \meta{$op_i$}
  should add edges to their input graphs between nodes colored
  |target'| and |source'|.
\end{description}




\subsection{Graph Macros}
\label{section-library-graphs-macros}

To be written...



\subsection{Placement Strategies}
\label{section-library-graphs-placement}

To be written...


\subsection{Reference: Standard Library}

To be written...

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual-pdftex-version"
%%% End: 
