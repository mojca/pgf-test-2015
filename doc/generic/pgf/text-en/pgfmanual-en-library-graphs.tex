% Copyright 2010 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Specifying Graphs}
\label{section-library-graphs}

\subsection{Overview}

\tikzname\ offers a powerful path command for specifying how the nodes
in a graph are connected by edges and arcs: The |graph| path
command, which becomes available when you load the |graph| library.

\begin{tikzlibrary}{graph}
  The package must be loaded to use the |graph| path command.
\end{tikzlibrary}


In this section, by \emph{graph} we refer to a set of nodes together
with some edges (sometimes also called arcs, in case they are
directed) such as the following:

\begin{codeexample}[]
\tikz \graph { a -> {b, c} -> d };  
\end{codeexample}

\begin{codeexample}[]
\tikz
  \graph [nodes={draw, circle}, clockwise, radius=.5cm, empty nodes, n=5] {
    subgraph I_n [name=inner] --[bipartite]
    subgraph I_n [name=outer]
  };
\end{codeexample}

\begin{codeexample}[]
\tikz
  \graph [nodes={draw, circle}, clockwise, radius=.75cm, empty nodes, n=8] {
    subgraph C_n [name=inner] <->[shorten <=1pt, shorten >=1pt]
    subgraph C_n [name=outer]
  };
\end{codeexample}

The nodes of a graph are normal \tikzname\ nodes, the edges are
normal lines drawn between nodes. There is nothing in the |graph|
library that you cannot do using the normal |\node| and the |edge|
command. Rather, its purpose is to offer a concise and powerful way of
\emph{specifying} which nodes are present 
and how they are connected. The |graph| library only offers simple
methods for specifying \emph{where} the nodes should be shown, its
main strength is in specifying which nodes and edges are present in 
principle. 

The |graph| library uses a syntax that is quite different from the
normal \tikzname\ syntax for specifying nodes. The reason for this is
that for many medium-sized graphs it can become quite cumbersome to
specify all the nodes using |\node| repeatedly and then using a great
number of |edge| command; possibly with complicated |\foreach|
statements. Instead, the syntax of the |graph| library is loosely
inspired by the \textsc{dot} format, which is quite useful for
specifying medium-sized graphs, with some extensions on top.



\subsection{Concepts}

The present section aims at giving a quick overview of the main
concepts behind the |graph| command. The exact syntax is explained in
more detail in later sections.


\subsubsection{Concept: Node Chains}

The basic way of specifying a graph is to write down a \emph{node
  chain} as in the following example: 

\begin{codeexample}[]
\tikz [every node/.style = draw]
  \graph { foo -> bar -> blub };  
\end{codeexample}

As can be seen, the text |foo -> bar -> my node| creates three nodes,
one with the text |foo|, one with |bar| and one with the text
|blub|. These nodes are connected by arrows, which are caused by
the |->| between the node texts. Such a sequence of node texts and
arrows between them is called a \emph{chain} in the following. 

Inside a graph there can be more than one chain:

\begin{codeexample}[]
\tikz \graph {
  a -> b -> c;
  d -> e -> f;
  g -> f;
};  
\end{codeexample}

Multiple chains are separated by a semicolon or a comma (both have
exactly the same effect). As the example shows, when a node text is
seen for the second time, instead of creating a new node, a connection
is created to the already existing node.

When a node like |f| is created, both the node name and the node text
are identical by default. This is not always desirable and can be
changed by using the |as| key:

\begin{codeexample}[]
\tikz \graph {
  x1 [as=$x_1$] -> x2 [as=$x_2$, red] -> x3 [as=$x_3$];
  x1 -> [bend left] x3;
};  
\end{codeexample}


\subsubsection{Concept: Chain Groups}

Multiple chains that are separated by a semicolon or a comma and that
are surrounded by curly braces form what will be called a \emph{chain
  group} or just a \emph{group}. A group in itself has no special
effect. However, things get interesting when you write down a node or
even a whole group and connect it to another group. In this case, the
``exit points'' of the first node or group get connected to the
``entry points'' of the second node or group:

\begin{codeexample}[]
\tikz \graph {
  a -> {
    b -> c,
    d -> e
  } -> f
};  
\end{codeexample}

Chain groups make it easy to create tree structures:

\begin{codeexample}[]
\tikz \graph [grow down, branch right=2.5cm] {
  root -> {
    child 1,
    child 2 -> {
      grand child 1,
      grand child 2
    },
    child 3 -> {
      grand child 3
    }
  }
};
\end{codeexample}

As can be seen, the placement is not particularly nice by default, but
may suffice in some situations.


\subsubsection{Concept: Node Sets}

When you write down some node text inside a |graph| command, a new
node is created by default unless this node has already been created
inside the same |graph| command. In particular, if a node has
already been declared outside of the current |graph| command, a new
node of the same name gets created.

This is not always the desired behaviour. Often, you may wish to make
nodes part of a graph than have already been defined prior to the use
of the |graph| command. For this, simply surround a node name by
parentheses. This will cause a reference to be created to an already
existing node:

\begin{codeexample}[]
\tikz {
  \node (a) at (0,0) {A};
  \node (b) at (1,0) {B};
  \node (c) at (2,0) {C};
  
  \graph { (a) -> (b) -> (c) };
}
\end{codeexample}

You can even go a step further: A whole collection of nodes can all be
flagged to belong to a \emph{node set} by adding the option
|set=|\meta{node set name}. Then, inside a |graph| command, you can
collectively refer to these nodes by surrounding the node set name in
parentheses: 

\begin{codeexample}[]
\tikz [new set=my nodes] {
  \node [set=my nodes, circle,    draw] at (1,1)   {A};
  \node [set=my nodes, rectangle, draw] at (1.5,0) {B};
  \node [set=my nodes, diamond,   draw] at (1,-1)  {C};
  \node (d)           [star,      draw] at (3,0)   {D};

  \graph { X -> (my nodes) -> (d) };
}
\end{codeexample}


\subsubsection{Concept: Graph Macros}

Often, a graph will consist -- at least in parts -- of standard
parts. For instance, a graph might contain a cycle of certain size or
a path or a clique. To facilitate specifying such graphs, you can
define a \emph{graph macro}. Once a graph macro has been defined, you
can use the name of the graph to make a copy of the graph part of the
graph currently being specified:

\begin{codeexample}[]
\tikz \graph { subgraph K_n [n=6, clockwise] };
\end{codeexample}

\begin{codeexample}[]
\tikz \graph { subgraph C_n [n=5, clockwise] -> mid };
\end{codeexample}

The library |graphs.standard| defines a number of such graphs,
including the complete clique $K_n$ on $n$ nodes, the complete
bipartite graph $K_{n,m}$ with shores sized $n$ and $m$, the cycle
$C_n$ on $n$ nodes, the path $P_n$ on $n$ nodes, and the independent
set $I_n$ on $n$ nodes.


\subsubsection{Concept: Graph Expressions and Color Classes}

When a graph is being constructed using the |graph| command, it is
constructed recursively by uniting smaller graphs to larger
graphs. During this recursive union process the nodes
of the graph get implicitly \emph{colored} (conceptually) and you can
also explicitly assign colors to individual nodes and even change the
colors as the graph is being specified. All nodes having the same
color form what is called a \emph{color class}.

The power of color class is that special \emph{connector operators}
allow you to add edges between nodes having certain colors. For instance,
saying |clique=red| at the beginning of a group will
cause all nodes that have been flagged as being (conceptually) ``red''
to be connected as a clique. Similarly, saying
|bipartite={red}{green}| will cause edges to be added
between all red and all green nodes. More advanced connectors, like
the |butterfly| connector, allow you to add edges between color
classes in a fancy manner.

\begin{codeexample}[]
\tikz [x=8mm, y=6mm, font=\footnotesize, circle]
  \graph [nodes={fill=blue!70, text=white}, empty nodes, n=8] {
    subgraph I_n [name=A] --[butterfly={level=4}]
    subgraph I_n [name=B] --[butterfly={level=2}]
    subgraph I_n [name=C] --[butterfly]
    subgraph I_n [name=D] -- 
    subgraph I_n [name=E]  
  };
\end{codeexample}



\subsection{Syntax of the Graph Path Command}

\subsubsection{The Graph Command}

In order to construct a graph, you should use the |graph| path
command, which can be used anywhere on a path at any place where
you could also use a command like, say, |plot| or |--|.

\begin{command}{\graph}
  Inside a |{tikzpicture}| this is an abbreviation for |\path graph|.
\end{command}

\begin{pathoperation}{graph}{\opt{\oarg{options}}\meta{group specification}}
  When this command is encountered on a path, the construction of the
  current path is suspended (similarly to an |edge| command or a
  |node| command). In a local scope, the \meta{options} are first
  executed with the key path |/tikz/graphs| using the following
  command:
  \begin{command}{\tikzgraphsset\marg{options}}
    Executes the \meta{options} with the path prefix |/tikz/graphs|.    
  \end{command}
  Apart from the keys explained in the following, further permissible
  keys will be listed during the course of the rest of this section.

  \begin{stylekey}{/tikz/graphs/every graph}
    This style is executed at the beginning of every |graph| path
    command prior to the \meta{options}.
  \end{stylekey}

  Once the scope has been set up and once the \meta{options} have been
  executed, a parser starts to parse the \meta{group
    specification}. The exact syntax of such a group specification
  in explained in detail in
  Section~\ref{section-library-graphs-group-spec}. Basically, a group
  specification is a list of chain specifications, separated by commas
  or semicolons.

  Depending on the content of the \meta{group specification}, two
  things will happen:
  \begin{enumerate}
  \item A number of new nodes may be created. These will be inserted
    into the picture in the same order as if they had been created
    using multiple |node| path commands at the place where the |graph|
    path command was used. In other words, all nodes created in a
    |graph| path command will be painted on top of any nodes created
    earlier in the path and behind any nodes created later in the
    path. Like normal nodes, the newly created nodes always lie on top
    of the path that is currently being created (which is often
    empty, for instance when the |\graph| command is used).
  \item Edges between the nodes may be added. They are added in the
    same order as if the |edge| command had been used at the position
    where the |graph| command is being used.
  \end{enumerate}

  Let us now have a look at some common keys that may be used inside
  the \meta{options}:
  \begin{key}{/tikz/graphs/nodes=\meta{options}}
    This option causes the \meta{options} to be applied to each newly
    created node inside the \meta{group specification}.
    \begin{codeexample}[]
\tikz \graph [nodes=red] { a -> b -> c };      
    \end{codeexample}
    Multiple uses of this key accumulate.
  \end{key}
  \begin{key}{/tikz/graphs/edges=\meta{options}}
    This option causes the \meta{options} to be applied to each newly
    created edge inside the \meta{group specification}.
    \begin{codeexample}[]
\tikz \graph [edges={red,thick}] { a -> b -> c };      
    \end{codeexample}
    Again, multiple uses of this key accumulate.
  \end{key}
  \begin{key}{/tikz/graphs/edge=\meta{options}}
    This is an alias for |edges|.
  \end{key}
  
  \begin{key}{/tikz/graphs/edge node=\meta{node specification}}
    This key specifies that the \meta{node specification} should be
    added to each newly created edge as an implicitly placed node. 
    \begin{codeexample}[]
\tikz \graph [edge node={node [red, near end] {X}}] { a -> b -> c };      
    \end{codeexample}
    Again, multiple uses of this key accumulate.
    \begin{codeexample}[]
\tikz \graph [edge node={node [near end] {X}},
              edge node={node [near start] {Y}}] { a -> b -> c };      
    \end{codeexample}
  \end{key}
  
  \begin{key}{/tikz/graphs/edge label=\meta{text}}
    This key is an abbreviation for
    |edge node=node[auto]{|\meta{text}|}|. The net effect is that the
    |text| is placed next to the newly created edges.
    \begin{codeexample}[]
\tikz \graph [edge label=x] { a -> b -> {c,d} };      
    \end{codeexample}
  \end{key}
  
  \begin{key}{/tikz/graphs/edge label'=\meta{text}}
    This key is an abbreviation for
    |edge node=node[auto,swap]{|\meta{text}|}|. 
    \begin{codeexample}[]
\tikz \graph [edge label=out, edge label'=in]
  { subgraph C_n [clockwise, n=5] };      
    \end{codeexample}
  \end{key}  
\end{pathoperation}


\subsubsection{Syntax of Group Specifications}
\label{section-library-graphs-group-spec}

A \meta{group specification} inside a |graph| path command has the
following syntax:
\begin{quote}
  |{|\opt{\oarg{options}}\meta{list of chain specifications}|}|
\end{quote}
The \meta{chain specifications} must contain chain specifications,
whose syntax is detailed in the next section, separated by either
commas or semicolons; you can freely mix them.
It is permissible to use empty lines (which are mapped to |\par|
commands internally) to structure the chains visually, they are simply
ignored by the parser. 

In the following example, the group specification consists of three
chain specifications, namely of |a -> b|, then |c| alone, and finally
|d -> e -> f|:
\begin{codeexample}[]
\tikz \graph {
  a -> b,
  c;

  d -> e -> f
};
\end{codeexample}
The above has the same effect as the more compact group specification
|{a->b,c,d->e->f}|.

Commas are used to detect where chain specifications end. However, you
will often wish to use a comma also inside the options of a single
node like in the following example:

\begin{codeexample}[]
\tikz \graph {
  a [red, draw] -> b [blue, draw],
  c [brown, draw, circle]
};
\end{codeexample}

Note that the above example works as expected: The first comma inside
the option list of |a| is \emph{not} interpreted as the end of the
chain specification ``|a [red|''. Rather, commas inside square
brackets are ``protected'' against being interpreted as separators of
group specifications.


The \meta{options} that can be given at the beginning of a group
specification are local to the group. They are executed with the path
prefix |/tikz/graphs|. Note that for the outermost group specification
of a graph it makes no difference whether the options are passed to
the |graph| command or whether they are given at the beginning of this
group. However, for groups nested inside other groups, it does make a
difference:

\begin{codeexample}[]
\tikz \graph {
  a -> { [nodes=red] % the option is local to these nodes:
    b, c
  } ->
  d
};
\end{codeexample}

There is special support for the |\foreach| statement inside groups:
You may use the statement inside a group
specification at any place where a \meta{chain specification} would
normally go. In this case, the |\foreach| statement is executed and
for each iteration the content of the statement's body is treated and
parsed as a new chain specification.

\begin{codeexample}[]
\tikz \graph [math nodes, branch down=5mm] {
  a -> { 
    \foreach \i in {1,2,3} {
      a_\i -> { x_\i, y_\i }
    },
    b
  }
};
\end{codeexample}


\subsubsection{Syntax of Chain Specifications}

A \meta{chain specification} has the following syntax: It consists of
a sequence of \meta{node specifications}, where subsequent node 
specifications are separated by \meta{edge specifications}. Node
specifications, which typically consist of some text, are discussed in
the next section in more detail. They normally represent a single node
that is either newly created or exists already, but they may also
specify a whole set of nodes.

An \meta{edge specification} specifies \emph{which} of the node(s) to
the left of the edge specification should be connected to which
node(s) to the right of it and it also specifies in which direction
the connections go. In the following, we only discuss how the
direction is chosen, the powerful mechanism behind choosing which
nodes should be connect is detailed in 
Section~\ref{section-library-graphs-color-classes}.

The syntax of an edge specification is always one of the following
five possibilities: 

\begin{quote}
  |->| \opt{\oarg{options}}\\
  |--| \opt{\oarg{options}}\\
  |<-| \opt{\oarg{options}}\\
  |<->| \opt{\oarg{options}}\\
  |-!-| \opt{\oarg{options}}
\end{quote}

The first four correspond to a directed edge, an undirected edge, a
``backward'' directed edge, and a bidirected edge, respectively. The
fifth edge specification means that there should be no edge (this
specification can be used together with the |simple| option to remove
edges that have previously been added, see
Section~\ref{section-library-graphs-simple}). 

Suppose the nodes \meta{left nodes} are to the left of the \meta{edge
  specification} and \meta{right nodes} are to the right and suppose
we have written |->| between them. Then the following happens:
\begin{enumerate}
\item The \meta{options} are executed (inside a local scope) with the
  path |/tikz/graphs|.  These options may setup the connector algorithm
  (see below) and may also use keys like |edge| or |edge label| to
  specify how the edge should look like. As a convenience, whenever an
  unknown key is encountered for the path |/tikz/graphs|, the key is
  passed to the |edge| key. This means that you can directly use
  options like |thick| or |red| inside the \meta{options} and they
  will apply to the edge as expected.
\item The chosen connector algorithm, see 
  Section~\ref{section-library-graphs-color-classes}, is used to
  compute from which of the \meta{left nodes} an edge should lead to
  which of the \meta{right nodes}. Suppose that $(l_1,r_1)$, \dots,
  $(l_n,r_n)$ is the list of node pairs that result (so there should
  be an edge between $l_1$ and $r_1$ and another edge between $l_2$
  and $r_2$ and so on).
\item For each pair $(l_i,r_i)$ an edge is created. This is done by
  calling the following key (for the edge specification |->|, other
  keys are executed for the other kinds of specifications):
  \begin{key}{/tikz/graphs/new ->=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    This key will be called for a |->| edge specification with the
    following four parameters: 
    \begin{enumerate}
    \item \meta{left node} is the name of the ``left'' node, that is,
      the name of $l_i$.
    \item \meta{right node} is the name of the right node.
    \item \meta{edge options} are the accumulated options from all
      calls of |/tikz/graph/edges| in groups that surround the edge
      specification.
    \item \meta{edge nodes} is text like |node {A} node {B}| that
      specifies some nodes that should be put as labels on the edge
      using \tikzname's implicit positioning mechanism.
    \end{enumerate}
    By default, the key executes the following code:
    \begin{quote}
      |\path [draw,->,|\meta{edge options}|]|\\
      \hbox{}\quad|(|\meta{left
        node}|\tikzgraphleftanchor) to |\meta{edge
        nodes}||\\
      \hbox{}\quad|(|\meta{right node}|\tikzgraphrightanchor);|
    \end{quote}
    You are welcome to change the code underlying the key.
  \end{key}
  \begin{key}{/tikz/graphs/left anchor=\meta{anchor}}
    This anchor is used for the node that is to the left of an edge
    specification. Setting this anchor to the empty string means that
    no special anchor is used (which is the default). The
    \meta{anchor} is stored in the macro |\tikzgraphleftanchor| with a
    leading dot.
    \begin{codeexample}[]
\tikz \graph {
  {a,b,c} -> [bipartite] {e,f,g}
};
    \end{codeexample}
    \begin{codeexample}[]
\tikz \graph [left anchor=east, right anchor=west] {
  {a,b,c} -- [bipartite] {e,f,g}
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/right anchor=\meta{anchor}}
    Works like |left anchor|, only for |\tikzgraphrightanchor|.
  \end{key}
  For the other three kinds of edge specifications, the following keys
  will be called:
  \begin{key}{/tikz/graphs/new --=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    This key is called for |--| with the same parameters as above. The
    only difference in the definition is that in the |\path| command
    the |->| gets replaced by |-|.
  \end{key}
  \begin{key}{/tikz/graphs/new <->=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |<->| with the same parameters as above. The |->| is
    replaced by |<-|
  \end{key}
  \begin{key}{/tikz/graphs/new <-=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |<-| with the same parameters as above. This will call
    |new ->| with the first two arguments exchanged.%
    \footnote{You might
      wonder why this key is needed: It seems more logical at first
      sight to just call |new edge directed| with swapped first
      parameters. Indeed, the default implementation of this key is to
      call |new edge directed| in such a way. However, a positioning
      algorithm might wish to take the fact that an edge is
      ``backward'' rater than ``forward'' into account in order to
      improve the layout.}
  \end{key}
  \begin{key}{/tikz/graphs/new -!-=\marg{left node}\marg{right node}\marg{edge options}\marg{edge nodes}}
    Called for |-!-| with the same parameters as above. Does nothing
    by default.
  \end{key}
\end{enumerate}

Here is an example that shows the default rendering of the different
edge specifications:

\begin{codeexample}[]
\tikz \graph {
  a -> b;
  c -- d;
  e <- f;
  g <-> h
};  
\end{codeexample}


\subsubsection{Syntax of Node Specifications}

\label{section-library-graphs-node-spec}

Node specifications are the basic building blocks of a graph
specification. There are three different possible kinds of node
specifications, each of which has a different syntax: 

\begin{description}
\item[Direct Node Specification] \meta{node name} \opt{\oarg{options}}
\item[Reference Node Specification] |(|\meta{node name or node set name}|)|
\item[Group Node Specification] \meta{group specification}
\end{description}

The rule for determining which of the three possible kinds is meant is
as follows: If the node specification starts with an opening
parenthesis, a reference node specification is meant; if it starts
with an opening curly brace, a group specification is meant; and in
all other cases a direct node specification is meant.

\medskip
\textbf{Direct Node Specifications.} If after reading the first symbol
of a node specification is has been detected to be \emph{direct},
\tikzname\ will collect all text up to the next edge
specification and store it as the \meta{node name}. Due to the way the
parsing works and due to the restrictions on node names, the following
characters are forbidding inside the \meta{node name}: Commas,
semicolons, hyphens, braces, dots, parentheses, and
presumably some more. So, it is best to avoid special characters
inside the \meta{node name}; but the following characters \emph{are}
definitely allowed: spaces, underscores, the hat character.

Once the node name has been determined, it is checked whether the same
node name was already used inside the current graph. If this is the
case, then we say that the already existing node is \emph{referenced};
otherwise we say that the node is \emph{fresh}.

\begin{codeexample}[]
\tikz \graph {
  a -> b; % both are fresh
  c -> a; % only c is fresh, a is referenced
};
\end{codeexample}

This behaviour of
deciding whether a node is fresh or referenced can, however, be
modified by using the following key:
\begin{key}{/tikz/graphs/use existing node=\opt{\meta{true or
        false}} (default true)}
  When this key is set to |true|, all nodes will be considered to the
  referenced, no node will be fresh. This option is useful if you have
  already created all the nodes of a graph prior to using the |graph|
  command and you now only wish to connect the nodes.
\end{key}

When a fresh node has been detected, a new node is created in the
inside a protecting scope. For this, the current
placement strategy is asked to compute a default position for the
node, see Section~\ref{section-library-graphs-placement} for
details. Then, the command
\begin{quote}
  |\node (|\meta{node name}|) [|\meta{node options}|] {|\meta{text}|};|
\end{quote}
is called. The different parameters are as follows:
\begin{itemize}
\item
  The \meta{node name} is normally the node name that has been
  determined as described before. However, there is one exception: If
  the node name is just an underscore, then a fresh internal node name
  is created that is guaranteed to be different from all node names
  used in this or any other graph. Thus, an underscore represents an
  anonymous fresh node.
\item 
  The \meta{node options} are
  \begin{enumerate}
  \item The options that have accumulated in calls to |nodes| from
    the surrounding scopes.
  \item The local \meta{options}.
  \end{enumerate}
  The options are executed with the path prefix |/tikz/graphs|, but
  any unknown key is executed with the prefix |/tikz|. This means, in
  essence, that some esoteric keys are more difficult to use inside
  the options and that any key with the prefix |/tikz/graphs| will
  take precedence over a key with the prefix |/tikz|).
\item The \meta{text} that is passed to the |\node| command is
  computed as follows: First, you can use the following key to
  directly set the \meta{text}: 
  \begin{key}{/tikz/graphs/as=\meta{text}}
    The \meta{text} is used as the text of the node. This allows you
    to provide a text for the node that differs arbitrarily from the
    name of the node.
    \begin{codeexample}[]
\tikz \graph { a [as=$x$] -- b [as=$y_5$] -> c [red, as={a--b}] };
    \end{codeexample}
  \end{key}
  This key always takes precedence over all of the mechanisms
  described below. In case the |as| key is not used, a default text
  is chosen as follows: The current value of the following key is used as
  \meta{text}:
  \begin{key}{/tikz/graphs/typeset=\meta{code}}
    The macro or code stored in this key is used as the
    \meta{text} if the node. Inside the \meta{code}, the following
    macros are available:
    \begin{command}{\tikzgraphnodetext}
      This macro expands to the \meta{node name}, except for
      anonymous fresh nodes, where it expands to the empty string.
    \end{command}
    \begin{command}{\tikzgraphnodepath}
      This macro expands to the current path of the node. These
      paths result from the use of graph macros, see
      Section~\ref{section-library-graphs-macros}.
    \end{command}
    \begin{command}{\tikzgraphnodefullname}
      This macro contains the concatenation of the above two.
    \end{command}
  \end{key}
  By default, the typesetter is just set to |\tikzgraphnodetext|,
  which means that the default text of a node is its name. However,
  it may be useful to change this: For instance, you might wish that
  the text of all graph nodes is, say, surrounded by parentheses:
  \begin{codeexample}[]
\tikz \graph [typeset=(\tikzgraphnodetext)]
  { a -> b -> c };
  \end{codeexample}
  A more advanced macro might take apart the node text and render it
  differently: 
  \begin{codeexample}[]
\def\mytypesetter{\expandafter\myparser\tikzgraphnodetext\relax}
\def\myparser#1 #2 #3\relax{%
  $#1_{#2,\dots,#3}$
}
\tikz \graph [typeset=\mytypesetter, grow down]
  { a 1 n -> b 2 m -> c 4 nm };
  \end{codeexample}
  The following styles install useful predefined typesetting macros:
  \begin{key}{/tikz/graphs/empty nodes}
    Just sets |typeset| to nothing, which causes all nodes to have an
    empty text (unless, of course, the |as| option is used):
    \begin{codeexample}[]
\tikz \graph [empty nodes, nodes={circle, draw}] { a -> {b, c} };  
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/math nodes}
    Sets |typeset| to |$\tikzgraphnodetext$|, which causes all nodes
    names to be typeset in math mode:
    \begin{codeexample}[]
\tikz \graph [math nodes, nodes={circle, draw}] { a_1 -> {b^2, c_3^n} };  
    \end{codeexample}
  \end{key}
\end{itemize}

If a node is referenced instead of fresh, then this node becomes the
node that will be connected by the preceding or following edge
specification to other 
nodes. The \meta{options} are executed even for a referenced node, but
they cannot be used to change the appearance of the node (because the
node exists already). Rather, the \meta{options} can only be used to
change the logical coloring of the node, see
Section~\ref{section-library-graphs-color-classes} for details.

\medskip
\textbf{Reference Node Specifications.} A reference node specification
is a node specification that starts with an opening parenthesis. In
this case, parentheses must surround a \meta{name} as in |(foo)|,
where |foo| is the \meta{name}. The following will now happen:

\begin{enumerate}
\item It is tested whether \meta{name} is the name of a currently
  active \emph{node set}. This case will be discussed in a moment.
\item Otherwise, the \meta{name} is interpreted and treated as a
  referenced node, but independently of whether the node has already
  been fresh in the current graph or not. In other words, the node
  must have been defined either already inside the graph (in which
  case the parenthesis are more or less superfluous) or it must have
  been defined outside the current picture.

  The way the referenced node is handled is the same way as for a
  direct node that is a referenced node.

  If the node does not already exist, an error message is printed.
\end{enumerate}

Let us now have a look at node sets. Inside a |{tikzpicture}| you can
locally define a \emph{node set} by using the following key:
\begin{key}{/tikz/new set=\meta{set name}}
  This will setup a node set named \meta{set name} within the current
  scope. Inside the scope, you can add nodes to the node set using the
  |set| key. If a node set of the same name already exists in the
  current scope, it will be reset and made empty for the current
  scope.

  Note that this command has the path |/tikz| and is normally used
  \emph{outside} the |graph| command.
\end{key}
\begin{key}{/tikz/set=\meta{set name}}
  This key can be used as an option with a |node| command. The
  \meta{set name} must be the name of a node set that has previously
  been created inside some enclosing scope via the |new set| key. The
  effect is that the current node is added to the node set.
\end{key}

When you use a |graph| command inside a scope where some node set
called \meta{set name} is defined, then inside this |graph| command
you use |(|\meta{set name}|)| to reference \emph{all} of the nodes in
the node set. The effect is the same as if instead of the reference to
the set name you had created a group specification containing a list
of references to all the nodes that are part of the node set.

\begin{codeexample}[]
\begin{tikzpicture}[new set=red, new set=green, shorten >=2pt]
  \foreach \i in {1,2,3} {
    \node [draw, red!80,         set=red]   (r\i) at (\i,1) {$r_\i$};
    \node [draw, green!50!black, set=green] (g\i) at (\i,2) {$g_\i$};
  }
  \graph {
    root [xshift=2cm] ->
    (red)             -> [bipartite, right anchor=south]
    (green)
  };
\end{tikzpicture}
\end{codeexample}

There is an interesting caveat with referencing node sets: Suppose
that at the beginning of a graph you just say |(foo);| where |foo| is
a set name. Unless you have specified special options, this will cause
the following to happen: A group is created whose members are all the
nodes of the node set |foo|. These nodes become referenced nodes, but
otherwise nothing happens since, by default, the nodes of a group are
not connected automatically. However, the referenced nodes have now
been referenced inside the graph, you can thus subsequently access
them as if they had been defined inside the graph. Here is an example
showing how you can create nodes outside a |graph| command and then
connect them inside as if they had been declared inside:

\begin{codeexample}[]
\begin{tikzpicture}[new set=import nodes]
  \begin{scope}[nodes={set=import nodes}] % make all nodes part of this set
    \node [red] (a) at (0,1) {$a$};
    \node [red] (b) at (1,1) {$b$};
    \node [red] (d) at (2,1) {$d$};
  \end{scope}

  \graph {
    (import nodes);         % "import" the nodes

    a -> b -> c -> d -> e;  % only c and e are new
  };
\end{tikzpicture}
\end{codeexample}


\medskip
\textbf{Group Node Specifications.}
At a place where a node specification should go, you can also instead
provide a group specification. Since nodes specifications are part of
chain specifications, which in turn are part of group specifications,
this is a recursive definition.

\begin{codeexample}[]
\tikz \graph { a -> {b,c,d} -> {e -> {f,g}, h} };
\end{codeexample}

As can be seen in the above example, when two groups of nodes are
connected via an edge specification, it is not immediately obvious
which connecting edges are added. This is detailed in
Section~\ref{section-library-graphs-color-classes}. 

\subsection{Simple Versus Multi-Graphs}

\label{section-library-graphs-simple}

The |graph| library allows you to construct both simple graphs and
multi-graphs. In a simple graph there can be at most one edge between
any two vertices, while in a multi-graph there can be multiple edges
(hence the name). The two keys |multi| and |simple| allow you to
switch (even locally inside on of the graph's scopes) between which
kind of graph is being constructed. By default, the |graph| command
produces a multi-graph since these are faster to construct.

\begin{key}{/tikz/graphs/multi}
  When this edge is set for a whole graph (which is the default) or
  just for a group (which is useful if the whole graph is simple in
  general, but a part is a multi-graph), then when you specify an edge
  between two nodes several times, several such edges get created:

\begin{codeexample}[]
\tikz \graph [multi] { % "multi" is not really necessary here
  a ->[bend left,  red]  b;
  a ->[bend right, blue] b;
};
\end{codeexample}
  In case |multi| is used for a scope inside a larger scope where the
  |simple| option is specified, then inside the local |multi| scope
  edges are immediately created and they are completely ignored when
  it comes to deciding which kind of edges should be present in the
  surrounding simple graph. From the surrounding scope's point of view
  it is as if the local |multi| graph contained no edges at all.

  This means, in particular, that you can use the |multi| option with
  a single edge to ``enforce'' this edge to be present in a simple
  graph. 
\end{key}

\begin{key}{/tikz/graphs/simple}
  In contrast a multi-graph, in a simple graph, at most one edge gets
  created for every pair of vertices:
\begin{codeexample}[]
\tikz \graph [simple]{
  a ->[bend left,  red]  b;
  a ->[bend right, blue] b;
};
\end{codeexample}
  As can be seen, the second edge ``wins'' over the first edge. The
  general rule is as follows: In a simple graph, whenever an edge
  between two vertices is specified multiple times, only the very last
  specification and its options will actually be executed.
  
  The real power of the |simple| option lies in the fact that you can
  first create complicated graph and then later redirect and otherwise
  modify edges easily: 

\begin{codeexample}[]
\tikz \graph [simple, grow right=2cm] {
  {a,b,c,d} ->[bipartite] {e,f,g,h};

  { [edges={red,thick}] a -> e -> d -> g -> a };
};
\end{codeexample}

  One particularly interesting kind of edge specification for a simple
  graph is |-!-|. Recall that this is used to indicate that ``no
  edge'' should be added between certain nodes. In a multi-graph, this
  key usually has no effect (unless the key |new -!-| has been
  redefined) and is pretty superfluous. In a simple graph, however, it
  counts as an edge kind and you can thus use it to remove an edge
  that been added previously:

\begin{codeexample}[]
\tikz \graph [simple] {
  subgraph K_n [n=8, clockwise];
  % Get rid of the following edges:
  1 -!- 2;
  3 -!- 4;
  6 -!- 8;
  % And make one edge red:
  1 --[red] 3;
};
\end{codeexample}

  Creating a graph such as the above in other fashions is pretty
  awkward.

  For every unordered pair $\{u,v\}$ of vertices at most one edge will
  be created in a simple graph. In particular, when you say |a -> b|
  and later also |a <- b|, then only the edge |a <- b| will be
  created. Similarly, when you say |a -> b| and later |b -> a|, then
  only the edge |b -> a| will be created. 

  The power of the |simple| command comes at a certain cost: As the
  graph is being constructed, a (sparse) array is created that keeps
  track for each edge of the last edge being specified. Then, at the
  end of the scope containing the |simple| command, for every pair of
  vertices the edge is created. This is implemented by two nested
  loops iterating over all possible pairs of vertices -- which may
  take quite a while in a graph of, say, 1000 vertices.
  Internally, the |simple| command is implemented as an operator that
  adds the edges when it is called, but
  this should be unimportant in normal situations.
\end{key}



\subsection{Graph Operators, Color Classes, and Graph Expressions}
\label{section-library-graphs-color-classes}

\tikzname's |graph| command employs a powerful mechanism for
adding edges between nodes and sets of nodes. To a graph theorist,
this mechanism may be known as a \emph{graph expression}: A graph is
specified by starting with small graphs and then applying
\emph{operators} to them that form larger graphs and that connect and
recolor colored subsets of the graph's node in different ways. 


\subsubsection{Color Classes}

\label{section-library-graph-coloring}

\tikzname\ keeps track of a \emph{(multi)coloring} of the graph as it
is being constructed. This does not mean that the 
actual color of the nodes on the page will be different, rather, in
the following we refer to ``logical'' colors in the way graph
theoreticians do. These ``logical'' colors are only important while
the graph is being constructed and they are ``thrown away'' at the end
of the construction. The actual (``physical'') colors of the nodes are
set independently of these logical colors.

As a graph is being constructed, each node can be part of one or more
overlapping \emph{color classes}. So, unlike what is sometimes called a
\emph{legal coloring}, the logical colorings that \tikzname\ keeps
track of may assign multiple colors to the same node and two nodes
connected by an edge may well have the same color.

Color classes must be declared prior to use. This is done using the
following key:
\begin{key}{/tikz/graphs/color class=\meta{color class name}}
  This sets up a new color class called \meta{color class name}. Nodes
  and whole groups of nodes can now be colored with \meta{color class
    name}. This is done using the following keys, which become
  available inside the current scope: 
  \begin{key}{/tikz/graphs/\meta{color class name}}
    This key internally uses the |operator| command to setup an
    operator that will cause all nodes of the current group to get the
    ``logical color'' \meta{color class name}. Nodes retain this color
    in all encompassing scopes, unless it is explicitly changed (see
    below) or unset (again, see below).
    \begin{codeexample}[]
\tikz \graph [color class=red] {
  [cycle=red]  % causes all "logically" red nodes to be connected in
               % a cycle
  a,
  b [red],
  { [red] c ->[bend right] d },
  e
};
    \end{codeexample}
    \begin{codeexample}[]
\tikz \graph [color class=red, color class=green, math nodes, clockwise, n=5] {
  [bipartite={red}{green}]
  { [red]   r_1, r_2 },
  { [green] g_1, g_2, g_3 }
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/not \meta{color class name}}
    Sets up an operator for the current scope so that all nodes in it
    loose the color \meta{color class name}. You can also use
    |!|\meta{color class name} as an alias for this key.
    \begin{codeexample}[]
\tikz \graph [color class=red, color class=green, math nodes, clockwise, n=5] {
  [bipartite={red}{green}]
  { [red]   r_1, r_2 },
  { [green] g_1, g_2, g_3 },
  g_2 [recolor green by=red]
};
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/recolor \meta{color class name} by=\meta{new color}}
    Causes all keys having color \meta{color class name} to get
    \meta{new color} instead. They loose having color \meta{color
      class name}, but other colors are not affected.
    \begin{codeexample}[]
\tikz \graph [color class=red, color class=green, math nodes, clockwise, n=5] {
  [bipartite={red}{green}]
  { [red]   r_1, r_2 },
  { [green] g_1, g_2, g_3 },
  g_2 [not green]
};
    \end{codeexample}
  \end{key}
\end{key}

The following color classes are available by default:
\begin{itemize}
\item 
  Color class |all|. Every node is part of this class by default. This
  is useful to access all nodes of a (sub)graph, since you can simply
  access all nodes of this color class. 
\item
  Color classes |source| and |target|. These classes are used to
  identify nodes that lead ``into'' a group of nodes and nodes from
  which paths should ``leave'' the group. Details on how these colors
  are assigned are explained in
  Section~\ref{section-library-graphs-join}. By saying |not source| or
  |not target| with a node, you can influence how it is connected:
  \begin{codeexample}[]
\tikz \graph { a -> { b, c, d } -> e };    
  \end{codeexample}
  \begin{codeexample}[]
\tikz \graph { a -> { b[not source], c, d[not target] } -> e };    
  \end{codeexample}
\item
  Color classes |source'| and |target'|. These are temporary colors
  that are also explained in
  Section~\ref{section-library-graphs-join}.
\end{itemize}



\subsubsection{Graph Operators on Groups of Nodes}

Recall that the |graph| command constructs graphs recursively from
nested \meta{group specifications}. Each such \meta{group
  specification} describes a subset of the nodes of the final graph. A
\emph{graph operator} is an algorithm that gets the nodes of a group
as input and (typically) adds edges between these nodes in some
sensible way. For instance, the |clique| operator will simply add
edges between all nodes of the group.

\begin{key}{/tikz/graphs/operator=\meta{code}}
  This key has an effect in three places:
  \begin{enumerate}
  \item It can be used in the \meta{options} of a \meta{direct node specification}.
  \item It can be used in the \meta{options} of a \meta{group
      specification}.
  \item It can be used in the \meta{options} of an \meta{edge specification}.
  \end{enumerate}
  The first case is a special case of the second, since it is treated
  like a group specification containing a single node. The last case
  is more complicated and discussed in the next section.
  So, let us focus on the second case.

  Even though the \meta{options} of a group are given at the beginning
  of the \meta{group specification}, the \meta{code} is only executed
  when the group has been parsed completely and all its nodes have
  been identified. If you use the |operator| multiple times in the
  \meta{options}, the effect accumulates, that is, all code passed to
  the different calls of |operator| gets executed in the order it is
  encountered. 

  The \meta{code} can do ``whatever it wants,'' but it will typically
  add edges between certain nodes. You can configure what kind of
  edges (directed, undirected, etc.) are created by using the
  following keys:
  \begin{key}{/tikz/graphs/default edge kind=\meta{value} (initially --)}
    This key stores one of the five edge kinds |--|, |<-|, |->|,
    |<->|, and |-!-|. When an operator wishes to create a new edge, it
    should typically set
    \begin{codeexample}[code only]
\tikzgraphsset{new \pfkeysvalueof{/tikz/graphs/default edge kind}=...}      
    \end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/--}
    Sets the |default edge kind| to |--|.
\begin{codeexample}[]
\tikz \graph { subgraph K_n [--, n=5, clockwise, radius=6mm] };      
\end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/->}
    Sets the |default edge kind| to |->|.
\begin{codeexample}[]
\tikz \graph { subgraph K_n [->, n=5, clockwise, radius=6mm] };      
\end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/<-}
    Sets the |default edge kind| to |<-|.
\begin{codeexample}[]
\tikz \graph { subgraph K_n [<-, n=5, clockwise, radius=6mm] };      
\end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/<->}
    Sets the |default edge kind| to |<->|.
\begin{codeexample}[]
\tikz \graph { subgraph K_n [<->, n=5, clockwise, radius=6mm] };      
\end{codeexample}
  \end{key}
  \begin{key}{/tikz/graphs/-!-}
    Sets the |default edge kind| to |-!-|.
  \end{key}
  
  When the \meta{code} of an operator is executed, the following
  commands can be used to find the nodes that should be connected:
  \begin{command}{\tikzlibgraphforeachcolorednode\marg{color name}\marg{macro}}
    When this command is called inside \meta{code}, the following will
    happen: \tikzname\ will iterate over all nodes inside the
    just-specified group that have the color \meta{color name}. The
    order in which they are iterated over is the order in which they
    appear inside the group specification (if a node is encountered
    several times inside the specification, only the first occurrence
    counts). Then, for each node the \meta{macro} is executed with the
    node's name as the only argument.

    In the following example we use an operator to connect every
    node colored |all| inside the subgroup to he node |root|. 
    \begin{codeexample}[]
\def\myconnect#1{\tikzset{graphs/new ->={root}{#1}{}{}}}      

\begin{tikzpicture}
  \node (root) at (-1,-1) {root};
  
  \graph {
    x,
    {
      [operator=\tikzlibgraphforeachcolorednode{all}{\myconnect}]
      a, b, c
    }
  };
\end{tikzpicture}
    \end{codeexample}
  \end{command}
  
  \begin{command}{\tikzlibgraphpreparecolor\marg{color
        name}\marg{counter}\marg{prefix}}
    This command is used to ``prepare'' the nodes of a certain color
    for random access. The effect is the following: It is counted how
    many nodes there are having color \meta{color name} in the current
    group and the result is stored in \meta{counter}. Next, macros
    named \meta{prefix}|1|, \meta{prefix}|2|, and so on are defined,
    that store the names of the first, second, third, and so on node
    having the color \meta{color name}.

    The net effect is that after you have prepared a color, you can
    quickly iterate over them. This is especially useful when you
    iterate over several color at the same time.

    As an example, let us create an operator then adds a zig-zag path
    between two color classes:
    \begin{codeexample}[]
\newcount\leftshorecount   \newcount\rightshorecount
\newcount\mycount          \newcount\myothercount
\def\zigzag{
  \tikzlibgraphpreparecolor{left shore}\leftshorecount{left shore prefix}
  \tikzlibgraphpreparecolor{right shore}\rightshorecount{right shore prefix}
  \mycount=0\relax
  \loop
    \advance\mycount by 1\relax%
    % Add the "forward" edge
    \tikzgraphsset{new ->=
      {\csname left shore prefix\the\mycount\endcsname}
      {\csname right shore prefix\the\mycount\endcsname}{}{}}
    \myothercount=\mycount\relax%
    \advance\myothercount by1\relax%
    \tikzgraphsset{new <-=
      {\csname left shore prefix\the\myothercount\endcsname}
      {\csname right shore prefix\the\mycount\endcsname}{}{}}    
  \ifnum\myothercount<\leftshorecount\relax
  \repeat
}
\begin{tikzpicture}
  \graph [color class=left shore, color class=right shore]
  { [operator=\zigzag]
    { [left shore, even shifts]                        a, b, c },
    { [right shore, even shifts, nodes={xshift=1cm}]   d, e, f }
  };
\end{tikzpicture}
\end{codeexample}
    Naturally, in order to turn the above code into a usable operator,
    some more code would be needed (like default values and taking
    care of shores of different sizes).
  \end{command}
\end{key}

There are a number of predefined operators, like |clique| or |cycle|,
see the reference Section~\ref{section-library-graphs-reference} for a
complete list.



\subsubsection{Graph Operators for Joining Groups}
\label{section-library-graphs-join}

When you join two nodes |foo| and |bar| by the edge specification
|->|, it is fairly obvious, what should happen: An edge from |(foo)|
to |(bar)| should be created. However, suppose we use an edge
specification between two node sets like |{a,b,c}| and |{d,e,f}|. In
this case, it is not so clear which edges should be created. One might
argue that all possible edges from any node in the first set to any node
in the second set should be added. On the other hand, one might also
argue that only a matching between these two sets should be
created. Things get even more muddy when a longer chain of node sets
are joined.

Instead of fixing how edges are created between two node sets,
\tikzname\ takes a somewhat more general, but also more complicated
approach, which can be broken into two parts. In the following, assume
that the following chain specification is given:
\begin{quote}
  \meta{spec$_1$} \meta{edge specification} \meta{spec$_2$}
\end{quote}
An example might be |{a,b,c} -> {d, e->f}|.

\medskip
\textbf{The source and target vertices.} Let us start with the
question of which vertices of the first node set should be connected to
vertices in the second node set.

There are two predefined special color classes that are used for this:
|source| and |target|. For every group specification, some vertices
are colored as |source| vertices and some vertices are |target|
vertices (a node can both be a target and a source). Initially, every
vertex is both a source and a target, but that can change as we will
see in a moment.

The intuition behind source and target vertices is that, in some
sense, edges ``from the outside'' lead into the group via the source
vertices and lead out of the group via the target vertices. To be more
precise, the following happens:
\begin{enumerate}
\item The target vertices of the first group are connected to
  the source vertices of the second group.
\item In the group resulting from the union of the nodes from
  \meta{spec$_1$} and \meta{spec$_2$}, the source vertices are only
  those from the first group, and the target vertices are only those
  from the second group.
\end{enumerate}

Let us go over the effect of these rules for the example
|{a,b,c} -> {d, e->f}|. First, each individual node is initially both
a |source| and a |target| vertex. Then, in |{a,b,c}| all nodes are
still both source and target vertices since just grouping vertices
does not change their colors. Now, in |e->f| something interesting
happens for the first time: the target vertices of the ``group'' |e|
(which is just the node |e|) are connected to the source vertices of
the ``group'' |f|. This means, that an edge is added from |e| to
|f|. Then, in the resulting group |e->f| the only source vertex is |e|
and the only target vertex is |f|. This implies that in the group
|{d,e->f}| the sources are |d| and |e| and the targets are |d| and~|f|.

Now, in |{a,b,c} -> {d,e->f}| the targets  of |{a,b,c}| (which are all
three of them) are connected to the sources of |{d,e->f}| (which are
just |d| and~|e|). Finally, in the whole graph only |a|, |b|, and |c|
are sources while only  |d| and |f| are targets.

\begin{codeexample}[]
\def\hilightsource#1{\fill [green, opacity=.25] (#1) circle [radius=2mm]; }  
\def\hilighttarget#1{\fill [red,   opacity=.25] (#1) circle [radius=2mm]; }  
\tikz \graph
  [operator=\tikzlibgraphforeachcolorednode{source}{\hilightsource},
   operator=\tikzlibgraphforeachcolorednode{target}{\hilighttarget}]
  { {a,b,c} -> {d, e->f} };
\end{codeexample}

The next objective is to make more precise what it means that ``the
targets of the first graph'' and the ``sources of the second graph''
should be connected. We know already of a general way of connecting
nodes of a graph: operators! Thus, we use an operator for this job.
For instance, the |bipartite| operator adds an edge from every node
having a certain color to every node have a certain other color. This
is exactly what we need here: The first color is ``the color |target|
restricted to the nodes of the first graph'' and the second color is
``the color |source| restricted to the nodes of the second graph.''

However, we cannot really specify that only nodes from a certain
subgraph are meant -- the |operator| machinery only operates on all
nodes of the current graph. For this reason, what really happens is
the following: When the |graph| command encounters \meta{spec$_1$}
\meta{edge specification} \meta{spec$_2$}, it first computes and
colors the nodes of the first and the second specification
independently. Then, the |target| nodes of the first graph are
recolored to |target'| and the |source| nodes of the second graph are
recolored to |source'|. Then, the two graphs are united into one
graph and a \emph{joining operator} is executed, which should add
edges between |target'| and |source'|. Once this is done, 
the colors |target'| and |source'| get erased. Note that in the
resulting graph only the |source| nodes from the first graph are still
|source| nodes and likewise for the |target| nodes of the second graph.


\medskip
\textbf{The joining operators.} The job of a joining operator is
to add edges between nodes colored |target'| and |source'|. The
following rule is used to determine which operator should be chosen
for performing this job:
\begin{enumerate}
\item If the \meta{edge specification} explicitly sets the |operator|
  key to something non-empty (and also not to |\relax|), then the
  \meta{code} of this |operator| call is used.
\item Otherwise, the current value of the following key is used: 
  \begin{key}{/tikz/graphs/default edge operator=\meta{key}}
    This key stores the name of a \meta{key} that is executed for every
    \meta{edge specification} whose \meta{options} do not contain the
    |operator| key.
\begin{codeexample}[]
\tikz \graph [default edge operator=matching] {
  {a, b}    ->[flow]
  {c, d, e} --[bipartite]
  {f, g, h} -- 
  {i, j, k}
};    
\end{codeexample}
  \end{key}
\end{enumerate}

A typical joining operator is |bipartite|. It takes the names of two
color classes as input and adds edges from all vertices of the first
class to all vertices of the second class. Now, the trick is that the
default value for the |bipartite| key is |{target'}{source'}|. Thus,
if you just write |->[bipartite]|, the same happens as if you had
written |->[bipartite={target'}{source'}]| -- which is exactly what we
want to happen. The same default values are also set for other
joining operators like |matching| or |butterfly|.

Note that even though an operator like |bipartite| is typically used
together with an edge specification, it can also be used as a normal
operator together with a group specification. In this case, however,
the color classes must be named explicitly:

\begin{codeexample}[]
\begin{tikzpicture}
  \graph [color class=red, color class=green, math nodes]
  { [bipartite={red}{green}]
    { [red,   even shifts]                      r_1, r_2, r_3 },
    { [green, even shifts, nodes={xshift=1cm}]  g_1, g_2, g_3 }
  };
\end{tikzpicture}
\end{codeexample}

A list of predefined joining operators can be found in the reference
Section~\ref{section-library-graphs-reference}.

Note that when the joining operator is executed for an \meta{edge
  specification}, the value of |default edge kind| will be temporarily
be set to the value of the \meta{edge specification}, 


% \subsubsection{Advanced: Semantics of Graph Specifications}

% \label{section-library-graphs-semantics}

% In the present section I describe the semantics of graph
% specifications on a more formal level. If you are not a graph
% theoretician, you may wish to skip this section. If you are a graph
% theoretician, enjoy.

% The graphs that the |graph| library handles are ``ordered
% multi-colored multi-graphs.'' Formally, we fix set $C$ of colors. Then
% in the following by ``graph'' we refer to a tuple consisting of:
% \begin{enumerate}
% \item A (finite) vertex set $V$.
% \item A set of edges $E$ together with a type function $\tau \colon E
%   \to \{ \leftarrow, \rightarrow,\leftrightarrow,-, \neg\}$ and two
%   mappings $s \colon E \to V$ and $t \colon E \to V$ assigning a start
%   and an end to each edge.
% \item For each color $i \in C$ a set $C_i \subseteq V$ of nodes
%   colored by $i$ (called the \emph{color class} $C_i$).
% \item A total ordering $<$ of $V$.
% \end{enumerate}

% The first three parts of the tuple are fairly standard, except perhaps
% for the type function $\tau$ that is used to tell us how the edge
% should be rendered (the ``kind $\neg$'' is used typically rendered as
% ``no edge,'' but formally it is just another type). Note that a graph
% node can have several different colors at the same time; you may also
% think of the colors as predicates. 

% Given two (or more) graphs over the same vertex set~$V$, their union
% is defined in the obvious way by taking the disjoint union of their
% edge sets (recall that we consider multi-graphs) and joining the color
% classes. 

% A \emph{graph expression} is a term $t$ over a certain set of
% operators and atomic expressions. Every such term \emph{evaluates} to
% a graph~$G$, and we write $G(t)$ for the graph that $t$
% evaluates to. First, for a set $V$ of nodes together with a total
% ordering $<$ on $V$, let $\nu(V,<)$ be the
% atomic expression that evaluates to the graph $G(\nu(V, <))$ whose
% vertex set is $V$, whose edge set and color classes are empty, and
% whose total ordering is~$<$. Second, let $X$ be an $n$-ary
% function that takes $n$ graphs and yields a new graph. Then for
% $n$ graph expressions $t_1$ to $t_n$, let $\mu_X(t_1,\dots,t_n)$ also be
% a graph expression. It is evaluated as follows:
% $G\bigl(\mu_X(t_1,\dots,t_n)\bigr) = X\bigl(G(t_1),\dots, G(t_n)\bigr)$.

% Let $\kappa_i^X$ be the function that takes a graph $G$ as input and
% outputs the graph $G'$ that is identical to $G$ but with all nodes in
% $X$ being colored by $i$, that is, $C_i'= C_i \cup X$. Similarly, let
% $\bar \kappa_i^X$ be the function that maps $G$ to $G'$ with $C_i'=C_i
% \setminus X$.

% As the |graph| command parses its \meta{group specification}, it
% builds a graph expression internally and evaluates it ``on the fly''
% to a graph. The set of nodes $V$ is (conceptually, not
% algorithmically) computed first: It is the set of all nodes names 
% ``mentioned'' in the specification (this includes direct nodes and
% also referenced nodes). The ordering $<$ is the ordering in which the
% nodes are first encountered when the \meta{group specification} is
% read sequentially.

% With $V$ and $<$ fixed, the graph expression described below are
% (conceptually) created as the specification is parsed. Then,
% (conceptually) the expression is evaluated and the edges in the
% resulting graph are then created using the keys
% like |new ->|.

% \begin{description}
% \item[Direct node specification] The syntactic construct
%   \meta{text}|[|\meta{options}|]| that corresponds to what was earlier
%   called a \emph{direct} node specification corresponds to the 
%   graph expression
%   $$\mu_{\kappa_{\mathtt{all}}^{\{\meta{text}\}}}(\mu_{\kappa_{\mathtt{source}}^{\{\meta{text}\}}}(
%   \mu_{\kappa_{\mathtt{target}}^{\{\meta{text}\}}}
%   (\nu(V, <)))).$$ In other words, the graph expression evaluates to a
%   graph in which there is exactly one node that is colored, namely the
%   node \meta{name}, and this node has the three colors |all|,
%   |source|, and |target|.

%   The \meta{options} are largely ignored, except if the
%   |operator=|\meta{op} key is used inside. In this case, 
%   \begin{quote}
%     \meta{text}|[|\meta{more options}|,operator=|\meta{$op_1$}%
%     |, operator=|\meta{$op_2$}%
%     |, |\dots|, operator=|\meta{$op_n$}|]|
%   \end{quote}
%   is mapped to the graph expression
%   $\mu_{\meta{$op_n$}}\bigl(\dots\bigr(\mu_{\meta{$op_1$}}(t)\bigr)\dots\bigr)$,
%   where $t$ is the expression from above.  
% \item[Group specifications] The syntactic construct
%   \begin{quote}
%     |{[|\meta{more
%         options}|, operator=|\meta{$op_1$}|, |\dots|, operator=|\meta{$op_n$}|] |
%       \meta{$A_1$}|, |\dots|, |\meta{$A_m$}|}|
%   \end{quote}
%   is handled as follows: Let $t_1$ to $t_m$ be the graph expressions
%   corresponding to $A_1$ to $A_m$. Then the resulting graph expression
%   is 
%   $$\mu_{\meta{$op_n$}}\bigl(\dots\mu_{\meta{$op_1$}}\bigr(\mu_{\cup}(t_1,\dots,t_m)\bigr)\dots\bigr).$$
%   Typically, the operators \meta{$op_i$} will add edges between the nodes
%   colored |all|. 
% \item [Chain specifications]
%   The syntactic construct
%   \begin{quote}
%     \meta{A} \meta{edge specification}|[|\meta{more
%       options}|, operator=|\meta{$op_1$}|, |\dots|, operator=|\meta{$op_n$}|]|
%     \meta{B}
%   \end{quote}
%   is handled as follows: Let $t$ and $t'$ be the graph expressions
%   corresponding to \meta{A} and \meta{B}. Then the resulting graph
%   expression is
%   $$\mu_Y\bigl(\mu_{\meta{$op_n$}}\bigl(\dots\bigr(\mu_{\meta{$op_1$}}(\mu_X(t,t')\bigr)\dots\bigr)\bigr).$$
%   Here, the operations $X$ and $Y$ work as follows:

%   The function $X$ takes two graphs $G$ and $H$ as input. Then in $G$,
%   the following \emph{recoloring} is performed: all
%   nodes that used to be colored |target| get colored |target'| instead
%   (no node is colored |target| afterward). In the
%   graph $H$, all nodes that used to be colored |source| get colored
%   |source'| instead. Then, the two graphs are united.

%   The function $Y$ takes a graph and simply removes the colors
%   |source'| and |target'|, that is, it is the concatenation  $\bar
%   \kappa_{\mathtt{source'}}^V \circ 
%   \kappa_{\mathtt{target'}}^V$.

%   The net effect of all of the above is that the operators \meta{$op_i$}
%   should add edges to their input graphs between nodes colored
%   |target'| and |source'|.
% \end{description}


\subsection{Graph Macros}
\label{section-library-graphs-macros}

To be written...



\subsection{Placement Strategies}
\label{section-library-graphs-placement}

To be written...


\subsection{Reference: Predefined Elements}

\label{section-library-graphs-reference}

\begin{tikzlibrary}{graph.standard}
  This library defines some additional graph macros and operators. 
\end{tikzlibrary}


\subsubsection{Subgraphs}


\subsubsection{Joining Operators}

\begin{key}{/tikz/graphs/bipartite}
  The |bipartite| connector simply adds edges
  between \emph{all} nodes of the sets:
\begin{codeexample}[]
\tikz \graph { {a, b}       ->[bipartite]  {c, d, e} --[bipartite]
               {g, h, i, j} --[bipartite]  k };    
\end{codeexample}
  To be continued...
\end{key}
\begin{key}{/tikz/graphs/induced bipartite}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/matching}
  The |matching| connector forms a maximum
  \emph{matching} between the nodes of the two sets. The first node of
  the first set is connected to the first node of 
  the second set, the second node of the first set is connected to the
  second node of the second set, and so on. If the sets have the same
  size, what results is what graph theoreticians call a \emph{perfect
    matching}, otherwise only a maximum, but not perfect matching
  results. 
\begin{codeexample}[]
\tikz \graph { {a, b, c} ->[matching] {d, e, f} --[matching]
               {g, h}    --[matching] {i, j, k} };    
\end{codeexample}
           To be continued...
\end{key}
\begin{key}{/tikz/graphs/flow}
 The |flow| connector works like the |matching|
  connector, only it behaves differently when the two to-be-connected
  sets have different size. In this case, all the surplus nodes get
  connected to the last node of the other set. This simple rule allows
  for some powerful effects (since this connector is the default,
  there is no need to add it here):
  \begin{codeexample}[]
\tikz \graph { a -> {b, c} -> {d, e} -- f};    
  \end{codeexample}
  The |flow| connector also makes it easy to create trees and
  series-parallel graphs.
  To be continued...
\end{key}

This following joining operator is defined in the |graphs.standard|
library:  

\begin{key}{/tikz/graphs/butterfly}
  To be written...
\end{key}


\subsubsection{Group Operators}

\begin{key}{/tikz/graphs/clique}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/path}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/induced path}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/induced cycle}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/cycle}
  To be written...
\end{key}
\begin{key}{/tikz/graphs/independent set}
  To be written...
\end{key}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual-pdftex-version"
%%% End: 
