% Copyright 2010-2011 by RenÃ©e Ahrens
% Copyright 2010-2011 by Olof Frahm
% Copyright 2010-2011 by Jens Kluttig
% Copyright 2010-2011 by Matthias Schulz
% Copyright 2010-2011 by Stephan Schuster
% Copyright 2011 by Jannis Pohlmann
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{The Interface Between the Layers of the Graph Drawing Engine}

{\noindent {\emph{by Ren\'ee Ahrens, Olof-Joachim Frahm, Jens Kluttig,
  Jannis Pohlmann, Matthias Schulz, Stephan Schuster, and Till Tantau}}}

\label{section-base-graphdrawing}
\label{section-gd-internals}

\begin{pgflibrary}{graphdrawing}
  This package provides the \TeX\ interface to the graph drawing
  engine. Since it uses \LuaTeX, you need at least \LuaTeX\ 0.4 or 
  higher.
\end{pgflibrary}

\begin{tikzlibrary}{graphdrawing}
  This library is what users will usually load. It loads the above
  library automatically. Nevertheless, the graph drawing engine can be
  used independently of \tikzname.
\end{tikzlibrary}



\subsection{Overview}

This chapter explains in detail how the different layers of the graph
drawing engine communicate. The main job of the graph drawing engine
is to provide a connection between the syntax of \tikzname\
and \pgfname\ for specifying graphs and code written in the Lua
programming language for computing layouts. The present section will
discuss this process in detail.

Let us start with the broad picture. The general idea behind the whole
graph drawing engine is that whenever \pgfname\ creates a node, we
intercept this node creation and \emph{do not} immediately place the
node. Rather, we pass it down to Lua, which tucks it away in
some internal tables. For edges, we introduce a special command called
|\pgfgdedge| that tells Lua that there is an edge between two
tucked-away nodes. Then, after the graph has been completely
specified, a graph drawing algorithm written in Lua starts to work on
the graph by computing new positions for the nodes. Then, the graph
drawing engine will send back the nodes and edges to \pgfname, which
then finally places them at their final positions.

Note that graph drawing algorithms need no knowledge of how any of
these internals work. Indeed, inside a graph drawing algorithm you get
access to a |graph| object that is an object-oriented model of the
graph. No \TeX\ programming skills are required to design and test a
graph drawing algorithm, only Lua is used here.

Let us now have a look at a simple example to see what happens when a
graph is specified:

\begin{codeexample}[]
\tikz[tree layout]
  \graph{root [as=Hello] -> World[fill=blue!20]};
\end{codeexample}

The special key |tree layout| internally calls the key
|graph drawing scope|, which in turn called that basic layer's macro
|\pgfgdbeginscope|, which starts up the graph drawing engine. Once this macro has been
called, until the next call of |\pgfgdendscope|, all nodes that are
created actually get passed down to the graph drawing engine. This is
implemented on the lowest layer, namely by directly intercepting
nodes freshly created using |\pgfnode|. In our example, this happens
in two places: For the |root| node and for the |World| node. The
|graph| library and \tikzname\ internally call the |\pgfnode| macro
for these two nodes (after a large number of internal syntax
translations, but the graph drawing engine does not care about them).

Note that the node boxes will have been fully created before they are
passed down to the graph drawing engine -- only their final position
is not yet fixed. It is not possible to modify the size of nodes
inside the graph drawing engine. 

In contrast, the single edge of the graph that is created by the |->|
command is not fully created before it is passed down to the
engine. This would not really make sense since before the final
positions of the nodes are fixed, we cannot even begin to compute the
length of this edge, let alone where it should start or end. For this
reason, on the upper \tikzname\ layer, the normal edge creation that
would be caused by |->| via |new ->| is suppressed. Instead, the
command |\pgfgdedge| is called. Similarly, inside a graph drawing
scope, \tikzname\ will suppress both the |edge| and the
|edge from parent| command and cause |\pgfgdedge| to be called
instead. 

An overview of what happens is illustrated by the following call graph:

\begin{tikzpicture}[
    class name/.style={draw,minimum size=20pt, fill=blue!20},
    object node/.style={draw,minimum size=15pt, fill=yellow!20},
    p/.style={->,>=stealth'},
    livespan/.style={thick,double},
    xscale=0.8]
  % class names above
  \node (tikz) at (0,4) [class name] {\tikzname\ layer};
  \node (tex) at (5,4) [class name] {\pgfname\ layer};
  \node (interface) at (10,4) [class name] {Lua: Class Interface};
  \node (sys) at (15,4) [class name] {Lua: Class Sys};
  % lines from the class names to the bottom of the picture
  \draw[livespan] (tikz) -- (0,-7.5);
  \draw[livespan] (tex) -- (5,-7.5);
  \draw[livespan] (interface) -- (10,-7.5);
  \draw[livespan] (sys) -- (15,-7.5);
  % first command: \graph{  -- generates new graph in lua interface
  \node (tikz-begin-graph) at (0,3) [object node] {|\graph[algorithm=...]{|}; %}
  \node (tex-begin-graph) at (5,3) [object node] {|\pgfgdbeginscope|};  
  \node (interface-new-graph) at (10,3) [object node] {|newGraph(|...|)|};
  \draw [p] (tikz-begin-graph.east) -- (tex-begin-graph.west);
  \draw [p] (tex-begin-graph.east) -- (interface-new-graph.west);    
  % second command: a -> b   -- generates two nodes in lua
  % and one edge
  \node (tikz-node) at (0,2) [object node] {|a -> b;|};
  \node (tex-node) at (5,2) [object node] {|\pgfnode|};
  \node (interface-add-node-behind) at (10.1,1.9) [object node] {|addNode(|...|)|};
  \draw[p] (tikz-node.east) -- (tex-node.west);
  
  \node (interface-add-node) at (10,2) [object node] {|addNode(|...|)|};
  \draw[p] (tex-node.east) -- (interface-add-node.west);

  \node (tex-add-edge) at (5,1) [object node] {|\pgfgdedge|};
  \node (interface-add-edge) at (10,1) [object node] {|addEdge(|...|)|};
  \draw[p] (tikz-node.east) -- (1.5,2) -- (1.5,1) -- (tex-add-edge.west);
  \draw[p] (tex-add-edge.east) -- (interface-add-edge.west);

  % scope ends -- cloes graph, layouts it and draws it
  \node (tikz-end) at (0,0) [object node] {|};|};
  \node (tex-end) at (5,0) [object node] {|\pgfgdendscope|};
  \node (interface-draw-graph) at (10,0) [object node] {|drawGraph()|};
  \node (interface-finish-graph) at (10,-2) [object node] {|finishGraph()|};

  \node (invoke-algorithm) at (12.5,-1) [object node] {invoke algorithm};
  \draw[p] (tikz-end.east) -- (tex-end.west);
  \draw[p] (tex-end.east) -- (interface-draw-graph.west);
  \draw[p] (interface-draw-graph.east) -- (12.5,0) -- (invoke-algorithm.north);
  \draw[p] (tex-end.east) -- (7.5,0) -- (7.5,-2) -- (interface-finish-graph.west);

  % begin shipout
  \node (sys-begin-shipout) at (15,-2) [object node] {|beginShipout()|};
  \draw[p] (interface-finish-graph.east) -- (sys-begin-shipout.west);
  \node (tex-begin-shipout) at (5,-3) [object node] {|\pgfgdbeginshipout|};
  \draw[p] (sys-begin-shipout.187) -- (12,-2.2) -- (12,-3) -- (tex-begin-shipout.east);

  % put tex box
  \node (sys-puttexbox-behind) at (15.1,-4.1) [object node] {|putTeXBox(|...|)|};
  \node (sys-puttexbox) at (15,-4) [object node] {|putTeXBox(|...|)|};
  \node (tex-puttexbox) at (5,-4.5) [object node] {|\pgfpositionnodenow|};
  \node (tex-putedge) at (5,-5.5) [object node] {|\pgfgdedgecallback|};

  \draw[p] (12.5,-2) -- (12.5,-4) -- (sys-puttexbox.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-4) -- (sys-puttexbox.west);
  \draw[p] (sys-puttexbox.187) -- ++(-2,0) |- (tex-puttexbox.east);

  % put edge
  \node (sys-put-edge-behind) at (15.1,-5.1) [object node] {|putEdge(|...|)|};
  \node (sys-put-edge) at (15,-5) [object node] {|putEdge(|...|)|};
  \draw[p] (sys-put-edge.187) -- ++(-2,0) |- (tex-putedge.east);
  \draw[p] (12.5,-4) -- (12.5,-5) -- (sys-put-edge.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-5) -- (sys-put-edge.west);
  % end shipout
  \node (sys-end-shipout) at (15,-6.5) [object node] {|endShipout()|};
  \draw[p] (12.5,-5) |- (sys-end-shipout.west);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-6) -- (sys-end-shipout.west);
  \node (tex-end-shipout) at (5,-7) [object node] {|\pgfgdendshipout|};
  \draw[p] (sys-end-shipout.187) -- ++ (-2,0) |- (tex-end-shipout.east);
\end{tikzpicture}


In Section~\ref{section-gd-scopes} we detail the different commands
needed to communicate with the graph drawing engine. In particular,
the commands for beginning and ending scopes are explained here. The
next section, Section~\ref{section-gd-parameters} explains how graph
parameters are setup and configured, both on the \TeX\ side and on the
Lua side. The remaining sections are dedicated entirely to the Lua
side of the graph drawing engine. We first give an overview and then
detail how new graph drawing algorithms can be implemented. This is
followed by a detailed reference of the avaiable classes and
functions. 




\subsection{Graph Drawing Scopes}
\label{section-gd-scopes}

Users of the graph drawing engine typically use a key like
|tree layout| to specify a graph drawing algorithm. This key is
actually just a style that uses the key |graph drawing scope|, which
in turn calls the macro |\pgfgdbeginscope|:

\begin{key}{/tikz/graph drawing scope}
  This key can (only) be used as an option when a \tikzname\ scope is
  started. Thus, you can pass it to |\tikz|, to |{tikzpicture}|, to
  |\scoped|, to |{scope}|, to |graph|, and to |{graph}|. For instance,
  the |tree layout| option (which uses |graph drawing scope| internally) can
  be used in the following ways:
\begin{codeexample}[]
\tikz [tree layout] \graph {a -> {b,c}};  

\tikz \graph [tree layout] {a -> {b,c}};

\tikz \path graph [tree layout] {a -> {b,c}};

\begin{tikzpicture}[tree layout]
  \graph {a -> {b,c}};
\end{tikzpicture}

\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,1);
  
  \scoped [tree layout] \graph {a -> {b,c}};
    
  \begin{scope}[tree layout, xshift=1cm, rotate=90]
    \graph {a -> {b,c}};
  \end{scope}
\end{tikzpicture}
\end{codeexample}

  You can \emph{not} use the |graph drawing scope| key with a single
  node or on a path. In particular, to typeset a tree given in the
  |child| syntax somewhere inside a |{tikzpicture}|, you must prefix
  it with the |\scoped| command:
\begin{codeexample}[]
\begin{tikzpicture}
  \scoped [tree layout]
    \node {root}
    child { node {left child} }
    child { node {right child} };
\end{tikzpicture}
\end{codeexample}
  Naturally, the above could have been written more succinctly as
\begin{codeexample}[]
\tikz [tree layout]
  \node {root}
  child { node {left child} }
  child { node {right child} };
\end{codeexample}
  Or even more succinctly:
\begin{codeexample}[]
\tikz \graph [tree layout] { root -- {left child, right child} };
\end{codeexample}

  In detail, adding the |graph drawing scope| command to a scope has
  the following effects:
  \begin{itemize}
  \item The basic layer is informed, using the
    |execute at begin scope| key, that the current scope will contain
    nodes that should be positioned by a graph drawing engine. Which
    algorithm is used depends on the value of the |algorithm| key.
  \item If the |graphs| library has been loaded, the default
    positioning mechanisms of this library are switched off, leaving
    the positioning to the graph drawing engine. Also, when an edge is
    created by the |graphs| library, this is signalled to the graph
    drawing library. (To be more precise: The keys |new ->| and so on
    are redefined so that they call |\pgfgdedge| instead of creating
    an edge.
  \item The |edge| path command is modified so that it also calls
    |\pgfgdedge| instead of immediately creating any edges.
  \item The |edge from parent| path command is modified so that is
    also calls |\pgfgdedge|.
  \item The keys |append after command| and |prefix after command|
    keys are modified so that they are executed only via
    |late options| when the node has ``reached its final parking
    position''. 
  \end{itemize}
\end{key}



\begin{command}{\pgfgdbeginscope}
  This macro starts a \TeX\ scope. The following things will happen:
  \begin{enumerate}
  \item A new |graph| object is created and put on the top of the Lua
    graph stack. All subsequent operations will work on this graph until
    |\pgfgdendscope| is called.
  \item Inside the scope, no nodes are placed immediately. Rather, 
    the macro |\pgfpositionnodelater|, see
    Section~\ref{section-shapes-deferred-node-positioning}, is used to
    send all nodes created inside the scope to some internal collector
    macro. This internal collector macro will pass down the created
    node to Lua.
  \item Some additional \meta{code} is executed, which has been set
    using the following command:
    \begin{command}{\pgfgdaddspecificationhook\marg{code}}
      This command adds the \meta{code} to the code that is executed
      whenever a graph drawing scope starts. For instance, the
      \tikzname\ library |graphdrawing| uses this macro to add some
      \meta{code} that will redirect the |edge| and |edge from parent|
      path commands to |\pgfgdedge|.
    \end{command}
  \item |\pgftransformreset| is called. See
    Section~\ref{section-gd-lua-coordinates} for details on the effect
    of this.
  \item The following \TeX-if is set to true:
    {
      \let\ifpgfgdgraphdrawingscopeactive=\relax
      \begin{textoken}{\ifpgfgdgraphdrawingscopeactive}
        Will be true inside a graph drawing scope.
      \end{textoken}
    }
  \end{enumerate}
  The above has a number of consequences for what can happen inside a
  graph drawing scope:
  \begin{itemize}
  \item Since no nodes are actually created before the end of the
    scope, you cannot reference these nodes. Thus, you cannot write
\begin{codeexample}[code only]
\tikz [spring layout] {
  \node (a) {a};
  \node (b) {b};
  \draw (a) -- (b);
}
\end{codeexample}
    The problem is that we cannot connect |(a)| and |(b)| via a
    straight line since these nodes do not exist at that point (they
    are available only deeply inside the Lua layer).
  \item In order to create edges between nodes inside a graph drawing
    scope, you need to call the |\pgfgdedge| command, described below.
  \end{itemize}
\end{command}


\begin{command}{\pgfgdendscope}
  This macro is used to end a graph drawing scope. It must be given on
  the same \TeX\ grouping level as the corresponding
  |\pgfgdbeginscope|. When the macro is called, it triggers a lot of
  new calls:
  \begin{enumerate}
  \item The special treatment of newly created boxes is ended. Nodes
    are once more created normally.
  \item The effects of the \meta{code} that was inserted via the
    specification hook command also ends (provided it had no global
    effects).
  \item Then, on the Lua layer, the graph drawing algorithm is
    started. Which algorithm is started, depends on the current value
    of the |algorithm| key, see below.
  \item When the algorithm has finished, a so-called \emph{shipout
      phase} is started.
  \item During this phase, all nodes that were intercepted during the
    graph drawing scope get inserted into the output stream at the
    positions that were computed for them. Also, for each edge that
    was requested via |\pgfgdedge|, the macro |\pgfgdedgecallback| is
    called (see below).

    The nodes are positioned \emph{before} the edges are drawn; after
    all, it is hard to draw an edge between nodes when their positions
    are not yet known. However, we typically want the nodes to be
    rendered \emph{after} or rather \emph{on top} of the edges. For
    this reason, the default behaviour is that the nodes at their
    final positions are collected in a box that is inserted into the
    output stream only after the edges have been drawn -- which has
    the effect that the nodes will be placed ``on top'' of the
    edges. This behaviour can be changed using the following keys:
\begin{key}{/graph drawing/nodes behind edges}
  \keyalias{tikz}\keyalias{tikz/graphs}
  When this key is invoked, nodes are placed \emph{behind} the edges:
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, nodes behind edges]
  { subgraph K_n [n=7] };    
\end{codeexample}
  When this key is used, you can still request individual edges to be
  placed \emph{behind} the nodes by putting them on the background
  layer:
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, nodes behind edges]
{ [simple]
  subgraph K_n [n=7];
  2 -> [on background layer, bend right=5] 6;
  4 -> [on background layer, bend right=5] 5;
};    
\end{codeexample}  
  Note, however, that when an edge is placed on the background layer,
  due to technical reasons, many graphic state options like changin
  the color will have no effect.
\end{key}
\begin{key}{/graph drawing/edges behind nodes}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is the default placemenet of edges: Behind the nodes.
\begin{codeexample}[]
\tikz \graph [spring layout, nodes={draw,fill=white}, edges behind nodes]
  { subgraph K_n [n=7] };    
\end{codeexample}
\end{key}
  \item Finally, the shipout phase is finished, the graph is popped
    from the graphs stack and the \TeX\ scope is ended. 
  \end{enumerate}
\end{command}



\begin{key}{/graph drawing/algorithm=\meta{algorithm's name}}
  \label{section-gd-algorithm-key}%
  This key specifies which algorithm should be used for typesetting a
  graph. The names of these algorithm's are often a bit cryptic (like
  |Spring Electrical Walshaw 2000| or something similar), which is why
  you typically do not call this key directly. Instead, styles with more
  easy-to-remember names internally set this key.

  Setting this key has the following effects: During the execution of
  |\pgfgdendscope|, Lua will try to find a class
  named \meta{algorithm's name} that has been declared using the
  |graph_drawing_algorithm| command (but any spaces inside the
  \meta{algorithm's name} are deleted). If it does not find such a
  class, the engine tries to  
  load the file called |pgfgd-algorithm-|\meta{algorithm's name}|.lua|
  (again, spaces are deleted) and then, again, tries to lookup the
  class. Thus, any class \meta{algorithm's name} mentioned inside a
  document must either have 
  already been defined in some Lua file loaded by some library or it
  must reside in a file with the corresponding name. Once the class
  has been found, the class's |new| method is called, the |graph|
  attribute of the object is set to the to-be-layouted graph, and the
  |run| method is called.
  
  Here is an example where we switch on the graph drawing engine
  explicitly and explicitly select an algorithm:
\begin{codeexample}[]
\tikz [graph drawing scope,
       /graph drawing/algorithm=Spring Electrical Walshaw 2000]
  \graph { a <-> {b, c} };  
\end{codeexample}
  The reference of the available algorithms is in
  Sections~\ref{section-first-graphdrawing-library-in-manual} to 
  \ref{section-last-graphdrawing-library-in-manual}.
\end{key}




As described above, inside a graph drawing scope, nodes are
automatically passed down to the graph drawing engine, while for edges
a command has to be called explicitly:

\begin{command}{\pgfgdedge\marg{first node}\marg{second
      node}\marg{edge direction}\marg{edge options}\marg{aux text}}
  This command is used to tell the graph drawing engine that there is
  an edge between \meta{first node} and \meta{second node} in your
  graph. The ``kind'' of connection is indicated by \meta{direction},
  which may be one of the following:
  \begin{itemize}
  \item 
    |->| indicates a directed edge (also known as an arc) from
    \meta{first node} to \meta{second node}.
  \item |--| indicates an undirected edge between \meta{first node}
    and \meta{second node},
  \item |<-| indicates a directed edge from \meta{second node} to
    \meta{first node}, but with the ``additional hint'' that this is a
    ``backward'' edge. A graph drawing algorithm may  or may not take
    this hint into account.
  \item |<->| indicates a bi-directed edge between \meta{first node}
    and \meta{second node}. 
  \item |-!-| indicates that the edge from \meta{first node} to
    \meta{second node} should be removed prior to processing the
    graph. It does not matter whether the edge to be removed was created
    as a directed edge (with |->|, |<-| or |<->|) or as an undirected
    edge.
  \end{itemize}
  The parameters \meta{edge options} and \meta{aux text} are a bit
  more tricky. When an edge between two vertices of a graph is created
  via |\pgfgdedge|, nothing is actually done immediately. After all,
  without knowing the final positions of the nodes \meta{first node}
  and \meta{second node}, there is no way of creating the actual
  drawing commands for the edge. Thus, the actual drawing of the edge
  is done only when the graph drawing algorithm is done (namely in the
  macro |\pgfgdedgecallback|, see later). 

  Because of this ``delayed'' drawing of edges, options that influence
  the edge must be retained until the moment when the edge is actually
  drawn. Parameters \meta{edge options} and \meta{aux text} store such
  options. 

  Let us start with \meta{edge options}. This parameter should be set
  to a list of key-value pairs like
\begin{codeexample}[code only]
/tikz/.cd, color=red, very thick, this edge must be vertical
\end{codeexample}
  Some of these options may be of interest to the graph drawing
  algorithm (like the last option) while others will 
  only be important during the drawing of edge (like the first
  option). The options that are important for the graph drawing
  algorithm must be passed to the algorithm via setting keys that have
  been declared using the handler |.edge parameter|, see
  Section~\ref{section-gd-parameters}. 

  The tricky part is that options that are of interest to the graph
  drawing algorithm must be executed \emph{before} the algorithm starts,
  but the options as a whole are usually only executed during the
  drawing of the edges, which is \emph{after} the algorithm has finished.
  To overcome this problem, the following happens:

  The options in \meta{edge options} are executed ``tentatively'' inside
  |\pgfgdedge|. However, this execution is done in a ``heavily guarded
  sandbox'' where all effects of the options (like changing the
  color or the line width) do not propagate beyond the sandbox. Only
  the changes of the graph drawing edge parameters leave the
  sandbox. These parameters are then passed down to the graph drawing
  engine.

  Later, when the edge is drawn using |\pgfgdedgecallback|, the
  options \meta{edge options} are available once more and then they
  are executed normally.

  Note that when the options in \meta{edge options} are executed, no
  path is preset. Thus, you typically need to start it with, say,
  |/tikz/.cd|. Also note that the sandbox is not perfect and changing
  global values will have an effect outside the sandbox. Indeed,
  ``putting things in a sandbox'' just means that the options are
  executed inside a \TeX\ scope inside an interrupted path inside a
  \TeX\ box that is thrown away immediately. 
  
  The text in \meta{aux text} is some ``auxilliary'' text that is
  simply stored away and later directly to |\pgfgdedgecallback|. This
  is used for instance by \tikzname\ to store its node labels. 
\end{command}


\begin{command}{\pgfgdsetedgecallback\marg{macro}}
  This command allows you to change the \meta{macro} that gets called
  form inside the graph drawing engine at the end of the creation of a
  graph, when the nodes have been positioned. The \meta{macro} will be 
  called once for each edge with the following parameters:
  \begin{quote}
    \meta{macro}\marg{first node}\marg{second
      node}\marg{direction}\marg{edge options}\marg{aux
      text}\marg{algorithm-generated options}\marg{bend information}
  \end{quote}

  The first five parameters are the original values that were passed
  down to the |\pgfgdedge| command.
  
  The \meta{algorithm-generated options} have been ``computed by the
  algorithm''. For instance, an algorithm might have determined, say,
  flow capacities for edges and it might now wish to communicate this
  information back to the upper layers. These options should be
  executed with the path |/graph drawing|.
  
  The parameter \meta{bend information} contains
  algorithmically-computed information concerning how the 
  edge should bend. Currently, this will be a text like
  |(10pt,20pt)--(30pt,40pt)| in \tikzname-syntax, but this may change
  to make things more portable.

  The default \meta{macro} simply draws a line between the nodes. When
  the |graphdrawing| library of the \tikzname\ layer is loaded, a more
  fancy \meta{macro} is used that takes all of the parameters into
  account.
\end{command}



\subsection{Parameters}
\label{section-gd-parameters}

When a graph drawing algorithm starts working, a set of options,
called ``graph drawing parameters'' or just ``parameters'' (in
constrast to ``options'') in the following, can influence
the way the algorithm works. For instance, a graph drawing parameter
might be the average distance between vertices which the algorithm
should take into account. Another example might be the fact the
certain nodes are special nodes and that a certain edge should have
a large label.

These graph drawing parameters are different from ``usual'' \pgfname\
options: An alogrithmic parameter influences the way the algorithm
works, while usual options influence the way the result
looks like. For instance, the fact that a node is red is not a
graph drawing parameter, while the shape of a node might be an graph
drawing parameter. 

Graph parameter should usually be keys with a path starting with
|/graph drawing| (although, strictly speaking, this is not
necessary). The following command makes it a bit easier to set them:
\begin{command}{\pgfgdset\marg{options}}
  Executes the \meta{options} with the path |/graph drawing|.  
\end{command}

There are three kinds of graph drawing parameters:

\begin{itemize}
\item \emph{Graph parameters:}
  These parameters influence ``the whole graph''. An example
  is the distance between vertices on the same level of a tree.
\item \emph{Node parameters:}
  These parameters are ``attached'' to a single node. This includes
  options that are only meaningful in the context of a graph
  drawing algorithm (like, say, the ``mass'' of a node in a
  force-based algorithm), but also hybrid attributed like the shape
  of a node. The shape is important for \pgfname\ when it typesets the 
  node, but it may also be important for the graph drawing
  algorithm since it might position circles differently from, say,
  rectangles.
\item \emph{Edge parameters:}
  Similarly to nodes, edges can also have graph drawing
  parameters. Also similarly to nodes, there can be purely
  graph drawing parameters and also options that are hybrid.
\end{itemize}
   
You have to ``declare'' a graph drawing parameter similarly to a
normal key, but instead of using the |.code| handler, you use
\begin{itemize}
\item |.graph parameter|,
\item |.node parameter|, and
\item |.edge parameter|.
\end{itemize}
More details on how these handlers work is given below.

Specifying the set of graph drawing parameters for a given graph or
node or edge works as follows: When the graph drawing engine is
started for a graph (using |\pgfgdbeginscope|), a snapshot is taken of
all graph drawing graph parameters currently setup at this
point. Similarly, when a node is created inside such a scope (using
|\pgfnode|), a snapshot is taken of the set of all graph drawing node
parameters in force at this point is taken and stored together with
the node. Finally, when an edge is created (using |\pgfgdedge|), a
snapshot of the setting of the graph drawing edge parameters is
taken. 

All of these option sets can easily be accessed inside the graph 
drawing algorithms.


In addition to the above kind of parameters, there are also two
``hybrid'' kind of parameter: ``Node or graph'' parameters and ``edge
or graph'' parameters. The idea behind these parameters is the
following: If such a parameter is specified before a graph
specification, it becomes a graph parameter; if it is specified inside
a graph specification is becomes a node or edge parameter. As an
example, the |sibling distance| is normally a graph parameter (because
it applies to all nodes), but it becomes a node parameter when given
to a single node.


\subsubsection{Basic Commands For Setting Parameters}

Let us start with the basic commands for setting a graph parameter
(you will not call these commands directly, in general).

\begin{command}{\pgfgdgraphparameter\marg{graph
      parameter}\marg{value}} 
  Sets the \meta{graph parameter} inside the local \TeX\ scope to
  \meta{value}. When |\pgfgdbeginscope| is encountered,
  the current settings of all graph parameters that have been set
  using this command will be passed down to the graph drawing
  engine. (Note that this happens right at the beginning of the graph
  drawing scope.)

  Inside a graph drawing algorithm, you can access to \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = graph:getOption('<graph parameter>');
\end{codeexample}
  where |<graph parameter>| should be the exact text passed as
  \meta{graph parameter}.

  In case that a graph parameter has not been set, the |getOption|
  function will return |nil| (but see also the description of the
  |.parameter initial| handler below).
\end{command}


\begin{command}{\pgfgdnodeparameter\marg{node
      parameter}\marg{value}} 
  Sets the \meta{node parameter} inside the local \TeX\ scope to
  \meta{value}. Unlike a graph parameter, this command can 
  be called inside a graph drawing scope. When a |\pgfnode| command is
  is encountered, the current settings of all node parameters that
  have been set using this command will be passed down to the graph
  drawing engine and will be stored alongside the node.

  Inside a graph drawing algorithm, you can access to \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = node:getOption('<node parameter>');
\end{codeexample}
  where |<node parameter>| should be the exact text passed as
  \meta{node parameter}. In case that a graph parameter has not been
  set, the |getOption| function will return |nil|.
\end{command}

\begin{command}{\pgfgdedgeparameter\marg{edge
      parameter}\marg{value}} 
  Works like |\pgfgdnodeparameter|, only for edges. Now, the values
  that have been set when |\pgfgdedge| is called are important. The
  settings can be accessed via 
\begin{codeexample}[code only]
  local myvalue = edge:getOption('<edge parameter>');
\end{codeexample}
\end{command}

\begin{command}{\pgfgdhybridnodegraphparameter\marg{parameter}\marg{value}}
  Calls |\pgfgdnodeparameter| when inside a graph drawing scope,
  otherwise |\pgfgdgraphparameter|.  
\end{command}

\begin{command}{\pgfgdhybridedgegraphparameter\marg{parameter}\marg{value}}
  As above, but for edges.
\end{command}

\subsubsection{Key Handlers  For Setting Parameters}

In practice, you do not call the above commands directly. Instead, you
use key handlers that will take care of calling these commands
internally.

\begin{handler}{{.graph parameter}|=|\opt{\meta{conversion}}}
  When this key hanlder is applied to a key, this key ``becomes a
  graph drawing graph parameter''. Subsequently, assigning a value to
  the key will cause an appropriate call of |\pgfgdgraphparameter| to
  be issued. For instance, suppose we say
\begin{codeexample}[code only]
\pgfkeys{ /some path/my key/.graph parameter }
\end{codeexample}
  and then subsequently
\begin{codeexample}[code only]
\pgfkeys{ /some path/my key=foo }
...
\pgfgdbeginscope
  ...
\pgfgdendscope
\end{codeexample}
  Then, inside the graph drawing scope, a call to
\begin{codeexample}[code only]
   local myvalue = graph:getOption('/some path/my key')
\end{codeexample}
  will set |myvalue| to |'foo'|.
  
  \medskip
  \noindent\textbf{Conversions.}
  In many cases, when you specify a graph parameter, you will not wish
  the original \meta{value} to be passed to the algorithm. For
  instance, suppose we write 
\begin{codeexample}[code only]
\pgfkeys{ /some path/width/.graph parameter }
\end{codeexample}
  We could now say |/some path/width=20pt+2pt|. Then, inside the 
  algorithm call to the function |getOptions('/some path/width')| would yield the
  string |'20pt+2pt'|. However, inside the algorithm, it would be
  somewhat preferable to have access to the value |22.0| rather than the
  string |'20pt+2pt'|. Similary, when the width is |1in|, the algorithm
  will   prefer to get passed the number |72.27| instead of |'1in'|.

  What we need is a \emph{conversion} of the value passed to the key
  before it is stored as a graph parameter. This is done by setting
  a \meta{conversion} when defining the key as a graph parameter. 
  
  Whenever a \meta{value} is assigned to the \meta{key}, the
  \meta{conversion} will be executed with path prefix
  |/graph drawing/conversions/|. The \meta{conversion} gets passed the
  \meta{value} and should store the ``result'' of the
  conversion in the macro |\pgfgdresult|. The contents of this macro is
  the text that will actually be passed down to the algorithm.

  As an example, let us have a look at a math conversion. This can be
  achieved as follows:
\begin{codeexample}[code only]
\pgfkeys{    
  /graph drawing/conversions/math/.code={
    \pgfmathparse{#1}                % Parse the <value>...
    \let\pgfgdresult\pgfmathresult   % and store the result in \pgfgdresult
  }
}
\end{codeexample}

  The following conversion are available by default:
  \begin{key}{/graph drawing/conversions/evaluate math
      expression=\meta{math expression}}
    Passes \meta{math expression} to |\pgfmathparse|.    
  \end{key}
  \begin{key}{/graph drawing/conversions/direction=\meta{direction}}
    The \meta{direction} may either be one of the directions |up|,
    |down|, |left|, |right|, |north|, |south|, |east|, |west|,
    |north east|, |north west|, |south east|, |south west|, or an
    angle. The result is always a number, so |south| would be replaced
    by |-90| just as |-45*2| would be.
  \end{key}
  \begin{key}{/graph drawing/conversions/coordinate=\meta{coordinate}}
    The \meta{coordinate} should have the form
    |(|\meta{number}|pt,|\meta{number}|pt)|. It is converted to the
    format |{|\meta{number}|}{|\meta{number}|}|.

    When you load the \tikzname\ library |graphdrawing| this
    conversion is overwritten by a more powerful conversion: You can
    then pass any \meta{coordinate} that is understood by
    \tikzname. It will still be converted into the
    pair-of-braced-numbers format.
  \end{key}
  
  \medskip
  \noindent\textbf{Default values.}
  When a graph parameter is not set at all, the call to |getOption|
  inside Lua will return |nil|. For most keys, however, a default
  value should be set, such as, say, |1cm| for a node distance. You
  \emph{cannot} just say |node distance/.initial=1cm| for a graph
  parameter |node distance| as one might expect since graph parameters
  are not normal keys. In principle, you could just say
  |node distance=1cm| in some outer scope to setup a default value for the
  key. However, due to the way graph parameters are implemented, if
  this were done for every graph parameter, huge lists of graph
  parameters would be passed around between \pgfname\ and Lua for each
  graph, even when the parameters are not used at all.

  For this reason, there is a special handler that allows you to setup
  initial values for graph parameters:
  \begin{handler}{{.parameter initial}|=|\meta{value}}
    Use this key handler instead of |.initial| to assign an initial value
    to a graph parameter. What will happen is that on the Lua layer,
    the passed \meta{value} is stored in a special table. Whenever the
    \meta{key} is not explicitly set by the user, the \meta{value}
    will be used.

    The \meta{value} gets passed through the \meta{conversion} of the
    graph parameter before it is stored.

    \emph{Remark:} Since the \meta{value} is passed down and managed
    by Lua, changing the initial value is always ``global.'' In
    particular, the values will not revert at the end of \TeX\
    scope. For this reason, you should use this handler only
    immediately after the key has been defined. Subsequently, a value
    should be assigned directly to the key rather than setting a new
    value using the handler once more.
\begin{codeexample}[code only]
\pgfgdset{
  node distance/.graph parameter=evaluate math expression,
  node distance/.parameter initial=1cm
}
\end{codeexample}
  \end{handler}
\end{handler}

\begin{handler}{{.node parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} In \tikzname, when you write |node [foo=bar] {...}|,
  the option |foo| is executed before |\pgfnode| is called
  internally. This means that if foo is a node parameter the ideal
  place to set it is, indeed, as an option of the node -- which is
  exactly what people expect.
\end{handler}

\begin{handler}{{.edge parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} When |\pgfgdedge| is executed, see also its
  documentation, it will ``tentatively'' execute its options. The only
  purpose of this ``tentative option execution'' is that options that
  are edge parameters get setup before the snapshot of the edge
  options is taken.  
\end{handler}


\begin{handler}{{.node or graph parameter}|=|\opt{\meta{conversion}}}
  This key works like |.node parameter| inside a graph drawing scope,
  otherwise it works like |.graph parameter|.
\end{handler}

\begin{handler}{{.edge or graph parameter}|=|\opt{\meta{conversion}}}
  As above, only for edges.
\end{handler}



\subsubsection{Advanced Commands For Setting Parameters}

Graph drawing parameters should have the path
|/graph drawing| for systematic reasons. However, as a user we do not
wish to write things like (which would work):
\begin{codeexample}[code only]
\tikz [/graph drawing/algorithm=my algorithm,
       /graph drawing/my algorithm/foo=bar,  
       /graph drawing/blub=foobar] ...
\end{codeexample}
Rather, we would like to write
\begin{codeexample}[code only]
\tikz [my algorithm={foo=bar}, blub=foobar] ...
\end{codeexample}


In order to achieve this and still keep the parameters in the correct
key path, \emph{key forwarding} is used. For most graph parameters, a
key of the same name with the path |/tikz| is setup that will just
forward its value to the corresponding key in the |/graph drawing|
path. Indeed, additionally, another forward is also setup from a key
of the same name with the path |/tikz/graphs|. You could, in
principle, even add new paths for which such forwards are setup.

Note that forwarding often also works when the key with the path
|/tikz| already does something else. In this case, the ``something
else'' will be done first and then the key will forward additionally
to the graph drawing key.

Graph parameters come in too flavours: ``common'' and
``family-specific.'' A ``common'' graph parameter can be used by
several graph drawing algorithms. An example are orientation keys,
which can actually be applied to any graph in a postprocessing
step. In contrast, ``family-specific'' keys are only important for
one algorithm or only for algorithms from a small family of
algorithms. For instance, a ``stiffness'' for spring layout algorithms 
would only apply to, well, spring layout algorithms.

The common graph parameters reside in the path |/graph drawing|,
while the family-specific graph parameters reside in the path
|/graph drawing/|\meta{family name}. For common graph parameters,
forwarding will be setup in paths like |/tikz| or |/tikz/graphs|, so
you can use these keys directly. In contrast, no forwarding will be
setup for family-specific keys. Rather, these keys can be passed to the
algorithm's key, which will in turn executed the keys with the
prefix |/graph drawing/|\meta{family name}.

Since setting up the forwards manually is cumbersome, there are some
special commands that should help you with this. We begin with
commands for setting up common graph parameters, but first we need a
command for specifying the list of paths from which we wish to
forward.

\begin{command}{\pgfgdappendtoforwardinglist\marg{path}}
  Appends the \meta{path} (with trailing slash) to the forwarding
  list. This means that all new keys declared using
  |\pgfgddeclareforwardedkeys| or |\pgfgddeclarealgorithmkey| will
  define a forwarding from a key with the prefix \meta{path} to the
  corrsponding key. 

  If a key has already been defined using one of the command,
  forwarding from \meta{path} will also 
  be setup for this key (using a bit of magic\ldots).  
\end{command}


\begin{command}{\pgfgddeclareforwardedkeys\marg{prefix}\marg{list of key declarations}}
  Each element in the \meta{list of key declarations} should have the
  form \meta{key name}|/|\meta{action}. For each element the following
  keys are setup:

  \begin{itemize}
  \item \meta{prefix}|/|\meta{key name}|/|\meta{actions}
  \item Provided that \meta{prefix}|/|\meta{keyname} was just defined
    for the first time just now, for each \meta{path} in the current
    forwarding list, a forwarding is added from the key
    \meta{path}|/|\meta{key name} to is \meta{prefix}|/|\meta{keyname}.
  \end{itemize}
  Typically, namely when \tikzname\ is used, the forwarding list is
  set to |/tikz,/tikz/graphs|. This means that you can use the
  \meta{key name} both in the |/tikz| and also in the |/tikz/graphs|
  namespace.
\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{
  node distance/.graph parameter=evaluate math expression,
  node distance/.parameter initial=1cm
}
\end{codeexample}
\end{command}


\begin{command}{\pgfgddeclarealgorithmkey\marg{algorithm  key}\marg{algorithm family}\marg{options}}
  This command will setup the following keys:
  
  \begin{key}{/graph drawing/\meta{algorithm key}=\meta{more options}}
    When this key is executed, the \meta{options} that were passed to
    the |\pgfgddeclarealgorithmkey| command are executed first with
    the path prefix |/graph drawing|. Next, the \meta{more options}
    are executed, but now with the path prefix
    |/graph drawing/|\meta{algorithm family}.

    Then, the following key is executed:
    \begin{key}{/graph drawing/at begin scope}
      This key does nothing by default, but it could be used to setup
      things (as is done in \tikzname) to start the graph drawing
      engine for the current scope. 
    \end{key}
  \end{key}

  Next, forwaring is setup from \meta{algorithm key} for all paths in
  the path list to |/graph drawing/|\meta{algorithm key}.
  
  The idea behind the \meta{algorithm family} is that several
  algorithms might share some keys. For
  instance, all spring-based algorithms are defined with the path
  prefix |/graph drawing/spring layout|. For them, the
  \meta{algorithm family} is set to |spring layout|.
\begin{codeexample}[code only]
\pgfgddeclarealgorithmkey
  {Walshaw2000 spring electrical}
  {spring layout}
  {
    algorithm=Spring Walshaw 2000,
    spring layout/temperature=0.95,
    spring layout/spring constant=0.01,
  }    
\end{codeexample}
\end{command}  



