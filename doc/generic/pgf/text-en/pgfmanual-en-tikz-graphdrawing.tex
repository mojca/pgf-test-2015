% Copyright 2010 by RenÃ©e Ahrens, Olof Frahm, Jens Kluttig, Matthias Schulz, Stephan Schuster
% Copyright 2011 by Till Tantau
% Copyright 2011 by Jannis Pohlmann
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Using Algorithmic Graph Drawing}

{\noindent {\emph{by Till Tantau and Ren\'ee Ahrens, Olof-Joachim
      Frahm, Jens Kluttig, Jannis Pohlmann, Matthias Schulz, Stephan
      Schuster}}} 

\label{section-library-graphdrawing}

\begin{tikzlibrary}{graphdrawing}
  This package provides capabilities for automatic graph drawing.

  \medskip
  \textbf{Note:} Graph drawing requires that the document is typeset
  using Lua\TeX. This package should work with \LuaTeX\ 0.4 or
  higher, which is included in all current \TeX\ distributions.
\end{tikzlibrary}

\ifluatex\relax\else{LuaTeX is required for setting this manual
  section.}\expandafter\endinput\fi 


\subsection{Overview}

\emph{Algorithmic graph drawing} (or just \emph{graph drawing} in the
following) means that algorithms are used to decide where the nodes of
a graph are positioned on a page so that the graph ``looks nice.'' The
idea is that you, as human (or you, as a machine, if you happen to be
a machine and happen to be reading this document) just specify which
nodes are present in a graph and which edges are
present. Additionally, you may add some ``hints'' like ``this node
should be near the center'' or ``this edge is pretty important.'' You
do \emph{not} specify where, exactly, the nodes and edges should
be. This is something you leave to a \emph{graph drawing
  algorithm}. The algorithm gets your description of the graph as an
input and then decides where the nodes should go on the page.

Naturally, graph drawing is a bit of a (black?) art. There is no
``perfect'' way of drawing a graph, rather, depending on the
circumstances there are several different ways of drawing the same
graph and often it will just depend on the aesthetic sense of the
reader which layout he or she would prefer. For this reason, there is
a huge number of graph drawing algorithms ``out there'' and there are
scientific conference devoted to such algorithms, where each
year dozens of new algorithms are proposed.

Unlike the rest of \pgfname\ and \tikzname, which is implemented
purely in \TeX, the graph drawing algorithms are simply too complex to
implement them in \TeX. Instead, the programming language Lua is used
by the graph drawing library -- a programming language that has been
integrated into recent versions of \TeX. This means that (a) as a user
of the graph drawing engine you will can run \TeX\ on your documents
in the usual way, no external programs are called since Lua is already
integrated into \TeX\ and (b) it is pretty easy to implement new graph
drawing algorithms for \tikzname\ since Lua can be used and no \TeX\
programming knowledge is needed. 

The graph drawing engine of \tikzname\ provides two main features:
\begin{enumerate}
\item ``Users'' of the graph drawing engine can invoke the graph
  drawing algorithms often by just adding a single option to their
  picture. Here is a typical example, where the |spring layout| option
  tells \tikzname\ that the graph should be drawn (``should be layed
  out'') using a so-called ``spring graph drawing algorithm'' (what
  these are will be explained later):
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (5,3);
  
  \graph [spring layout, grow=up]
    { a -> { subgraph K_n [n=4] } -> b };

  \graph [spring electrical layout, grow=up]
    { a [x=5] -> { subgraph K_n [n=4] } -> b };
\end{tikzpicture}
\end{codeexample}
  Here is another example, where a different layout method is used
  that is more appropriate for trees:
\begin{codeexample}[]
\tikz [grow'=up, tree layout]
  \node {root}
  child { node {left child} }
  child { node {right child} };
\end{codeexample}
  An a final example, this time using a ``spring electrical layout''
  (whatever that might be\dots):
\begin{codeexample}[]
\tikz [spring electrical layout]
{
  \foreach \i in {1,...,6}
    \node (node \i) [fill=blue!50, text=white, circle] {\i};
    
  \draw (node 1) edge (node 2)
        (node 2) edge (node 3)
        (node 3) edge (node 4)
                 edge (node 5)
                 edge (node 6);
}
\end{codeexample}
  In all of the example, the positions of the nodes have only been
  computed \emph{after} all nodes have been created and the edges have
  been specified. For instance, in the last example without the
  |spring layout| option, all of the nodes would have been placed on
  top of each other.
\item The graph drawing engine is also intended to make is
  (relatively) easy to implement new graph drawing algorithms. These
  algorithms can and must be implemented in the Lua programming
  language (which is \emph{much} easier to program than \TeX\
  itself). The Lua code for a graph drawing algorithm gets an
  object-oriented model of the input graph as an input and must just
  compute the desired new positions of the nodes. The complete
  handling of passing options and configurations back-and-forth
  between the different \tikzname\ and \pgfname\ layers is handled by
  the graph drawing engine.

  The bottom line is that the graph drawing engine makes it easy
  to try out new graph drawing algorithms for medium sized graphs (up
  to a few hundred nodes).
\end{enumerate}

The documentation of the graph drawing engine is structured as
follows: The current section explains the graph drawing engine from
``the user's point of few'' and also describes the basic steps
necessary to implement a new graph drawing algorithm. The libraries
containing the different graph drawing algorithms are documented in
Sections on graph drawing
algorithms. Section~\ref{section-gd-own-algorithm} covers the
internals of how the graph drawing engine works. 


\subsection{Usage}

To use the graph drawing engine, you first need to load some
libraries. First, you should always load the |graphdrawing| library,
which will setup the basic keys. Next, you need to load another
library like |graphdrawing.trees|, see the following
Sections~\ref{section-first-graphdrawing-library-in-manual} to
\ref{section-last-graphdrawing-library-in-manual} for the different
libraries that are available. The actual graph drawing
algorithms reside in these libraries. Finally, you may also wish to
load the |graphs| library, but this is only necessary if you wish to
use the |graph| path command, which provides an easy-to-use syntax for
specifying graphs. You can also use the graph drawing engine
independently of the |graphs| library, for instance in conjunction
with the |child| or the |edge| syntax. Here is a typical setup:

\begin{codeexample}[code only]
\usetikzlibrary{graphs,graphdrawing,graphdrawing.trees}  
\end{codeexample}

Having setup things, you must then specify for which scopes the
graph drawing engine should apply an layout algorithm to the nodes in
the scope. Typically, you just add an option ending with |... layout|
to the |graph| path operation and then let the graph drawing do its
magic:

\begin{codeexample}[]
\tikz [rounded corners]
  \graph [layered layout]
  {
    a -> {
      b,
      c -> { d, e }
    } ->
    f -> 
    a
  };    
\end{codeexample}

Whenever you use such an option, (to be more precise, inside every
scope with the |graph drawing scope| key set either
explicitly or implicitly, which is exactly what happens when one such
an option is used) you can:
\begin{itemize}
\item Create nodes in the usual way. The nodes will be created
  completely, but then tucked away in an internal table. This means
  that all of \tikzname's options for nodes can be applied. You can
  also name a node and reference it later.
\item Create edges using either the syntax of the |graph| command
  (using |--|, |<-|, |->|, or |<->|), or using the |edge| command,
  or using the |child| command. These edges will, however, not be
  created immediately. Instead, the basic layer's command
  |\pgfgdedge| will be called, which stores ``all the information
  concerning the edge.'' The actual drawing of the edge will only
  happen after all nodes have been positioned.
\item Most of the keys that can be passed to an edge will work as
  expected. In particular, you can add labels to edges using the
  usual |node| syntax for edges.
\item The |label| and |pin| options can be used in the usual manner
  with nodes inside a graph drawing scope. Only, the labels and
  nodes will play no role in the positioning of the nodes and they
  are added when the nodes are finally positioned.
\item Similarly, nodes that are placed ``on an edge'' using the
  implicit positioning syntax can be used in the usual manner. 
\end{itemize}
Here are some things that will \emph{not} work:
\begin{itemize}
\item Only edges created using the graph syntax, the |edge| command,
  or the |child| command will correctly pass their connection
  information to the basic layer. When you write |\draw (a)--(b);|
  inside a graph drawing scope, where |a| and |b| are nodes that
  have been created inside the scope, you will get an error
  message / things will look wrong. The reason is that the usual
  |--| is not ``caught'' by the graph drawing engine and, thus,
  tries to immediately connect two nodes that do not yet exist
  (except inside some internal table).
\item The options of edges are executed twice: Once when the edge is
  ``examined'' by the |\pgfgdedge| command (using some magic to shield
  against the side effects) and then once more when the edge is
  actually created. Fortunately, in almost all cases, this will not be
  a problem; but if you do very evil magic inside your edge options,
  you must roll a D100 to see what strange things will happen. (Do no
  evil, by the way.)
\end{itemize}

The rest of this subsection describes the ``fine print'' of what
happens, in detail. You may wish to skip it.

\medskip
\noindent\textbf{The Details.}
Let us start with some background knowledge on how the graph drawing
engine works might be useful: Using a special internal key called
|graph drawing scope|, which you typically will not call directly,
the graph drawing engine can be switched on for a |{scope}|. When this
happens, a lot of things change inside \pgfname\ and \tikzname\ for
this scope: First, all nodes created inside the scope are not
immediately placed at the position where they were created. Instead,
they are ``spirited away'' to some internal table of the graph drawing
engine. Second, all edges created inside the scope using either the
|graph| command, the |edge| command, or the |child| command are also
``spirited away'' to another internal table. Then, at the end of the
scope, the graph drawing algorithm is started, which has access to
these internal tables of nodes and edge of the graph that has been
specified inside the scope. The algorithm will then compute new,
better, positions for the nodes. Finally, once the positions have been
computed, the graph drawing engine will then retrieve the nodes from
the internal table and place them at the computed positions and it
also retrieves the edges from the internal table and also adds them to
the picture.

While this theory may sound complicated, the use of the graph library
is, fortunately, pretty simple: Just add a key like |tree layout| or
|spring layout| to a scope and leave out any explicit positioning via
things like |at| -- the positioning will be done automatically by the
graph drawing algorithm.

The keys like |tree layout| or |spring layout| are explained in more detail
in the chapters on the different libraries. They all internally call
(at least) two keys: |graph drawing scope| and |algorithm|. These
keys are documented in the following, but you typically will not use
them explicitly. In addition to setting up the scope and setting the
correct algorithms, keys like |tree layout| and |spring layout| also take
some \meta{options} as arguments. These \meta{options} allow you setup
special graph parameters for the algorithm.

\begin{key}{/tikz/graph drawing scope}
  This key can (only) be used as an option when a \tikzname\ scope is
  started. Thus, you can pass it to |\tikz|, to |{tikzpicture}|, to
  |\scoped|, to |{scope}|, to |graph|, and to |{graph}|. For instance,
  the |tree layout| option (which uses |graph drawing scope| internally) can
  be used in the following ways:
\begin{codeexample}[]
\tikz [tree layout] \graph {a -> {b,c}};  

\tikz \graph [tree layout] {a -> {b,c}};

\tikz \path graph [tree layout] {a -> {b,c}};

\begin{tikzpicture}[tree layout]
  \graph {a -> {b,c}};
\end{tikzpicture}

\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,1);
  
  \scoped [tree layout] \graph {a -> {b,c}};
    
  \begin{scope}[tree layout, xshift=1cm, rotate=90]
    \graph {a -> {b,c}};
  \end{scope}
\end{tikzpicture}
\end{codeexample}

  You can \emph{not} use the |graph drawing scope| key with a single
  node or on a path. In particular, to typeset a tree given in the
  |child| syntax somewhere inside a |{tikzpicture}|, you must prefix
  it with the |\scoped| command:
\begin{codeexample}[]
\begin{tikzpicture}
  \scoped [tree layout]
    \node {root}
    child { node {left child} }
    child { node {right child} };
\end{tikzpicture}
\end{codeexample}
  Naturally, the above could have been written more succinctly as
\begin{codeexample}[]
\tikz [tree layout]
  \node {root}
  child { node {left child} }
  child { node {right child} };
\end{codeexample}
  Or even more succinctly:
\begin{codeexample}[]
\tikz \graph [tree layout] { root -- {left child, right child} };
\end{codeexample}

  In detail, adding the |graph drawing scope| command to a scope has
  the following effects:
  \begin{itemize}
  \item The basic layer is informed, using the
    |execute at begin scope| key, that the current scope will contain
    nodes that should be positioned by a graph drawing engine. Which
    algorithm is used depends on the value of the |algorithm| key.
  \item If the |graphs| library has been loaded, the default
    positioning mechanisms of this library are switched off, leaving
    the positioning to the graph drawing engine. Also, when an edge is
    created by the |graphs| library, this is signalled to the graph
    drawing library. (To be more precise: The keys |new ->| and so on
    are redefined so that they call |\pgfgdedge| instead of creating
    an edge.
  \item The |edge| path command is modified so that it also calls
    |\pgfgdedge| instead of immediately creating any edges.
  \item The |edge from parent| path command is modified so that is
    also calls |\pgfgdedge|.
  \item The keys |append after command| and |prefix after command|
    keys are modified so that they are executed only via
    |late options| when the node has ``reached its final parking
    position''. 
  \end{itemize}
\end{key}

\begin{key}{/graph drawing/algorithm=\meta{algorithm's name}}
  \label{section-gd-algorithm-key}%
  This key specifies which algorithm should be used for typesetting a
  graph. The names of these algorithm's are often a bit cryptic (like
  |Walshaw2000| or something similar), which is why you typically do
  not call this key directly. Instead, styles with more
  easy-to-remember names internally set this key.

  Setting this key has the following effects: When a scope with the
  |graph drawing scope| command is started, the current value of
  \meta{algorithm's name} is examined. Lua will try to find a class
  named \meta{algorithm's name} in the |pgf.graphdrawing|
  namespace (but any spaces inside the \meta{algorithm's name} are
  deleted). If it does not find such a class, the engine tries to 
  load the file called |pgfgd-algorithm-|\meta{algorithm's name}|.lua|
  (again, spaces are deleted) and then, again, tries to lookup the
  class. Thus, any class \meta{algorithm's name} mentioned inside a
  document must either have 
  already been defined in some Lua file loaded by some library or it
  must reside in a file with the corresponding name. Once the class
  has been found, an object of this class is instantiated, the |graph|
  attribute of the object is set to the to-be-layouted graph, the
  |constructor| method of the class is called for the object (if it
  exists) and, finally, the |run| method is called. Details of what
  should be done in these methods are given in
  Section~\ref{section-gd-own-algorithm}).  

  Here is an example where we switch on the graph drawing engine
  explicitly and explicitly select an algorithm:
\begin{codeexample}[]
\tikz [graph drawing scope,
       /graph drawing/algorithm=Walshaw 2000 Spring Electrical]
  \graph { a <-> {b, c} };  
\end{codeexample}

  The reference of the available algorithms is in
  Sections~\ref{section-first-graphdrawing-library-in-manual} to 
  \ref{section-last-graphdrawing-library-in-manual}.
\end{key}




\subsection{Graph, Node, and Edge Parameters}

Graph drawing algorithms can typically be configured in some way. For
instance, for a graph drawing algorithm that visualizes its nodes as a
tree, it will typically be useful when the user can change the
so-called \emph{level distance} and the \emph{sibling distance}. For
other algorithms, like force-based algorithms, a large number of
parameters influence the way the algorithms work.

Options that influence graph drawing algorithms will be called
\emph{graph drawing parameters} in the following. There are three kinds of
graph drawing parameters:
\begin{itemize}
\item Graph parameters,
\item node parameters, and
\item edge parameters.
\end{itemize}
A graph drawing graph parameter influences the layout of the whole
graph. A graph drawing node parameter is an option that is attached to
a single node and should only have a direct influence on this node
(like ``place this node exactly at this position, no matter what''). A
graph drawing edge parameter in important for a single edge (like
``this edge must be exactly |2cm| long'').

A graph drawing algorithm may or may not take the different graph
parameters into account. After all, these options may even outright
contradict each other, so an algorithm can only try to ``do its
best''.

While many graph parameters are very specific to a single algorithm, a
number of graph parameters will be important for many algorithms. Such
graph parameters are called \emph{common} graph parameters, the most
important of which are documented in the following. The common graph
parameters can be used like any normal \tikzname\ option. In contrast,
specific options for algorithms must be passed to the key that
installs the algorithm. For example, the orientation of a graph
is setup with the common key |orient|, which is given alongside a key
like |spring layout|:

\begin{codeexample}[]
\tikz \graph [spring layout, orient=1|2] { 1--2--3--1 };  
\end{codeexample}

In contrast, the very specific option |iterations| must be
passed to the |spring layout| key:

\begin{codeexample}[]
\tikz \graph [spring layout={iterations=3}] { 1--2--3--1 };  
\end{codeexample}



\subsection{Anchoring a Graph}

\label{subsection-library-graphdrawing-anchoring}

A graph drawing algorithm must compute positions of the nodes of a
graph, but the computed positions are only \emph{relative} (``this
node is left of this node, but above that other node''). It is not
immediately obvious where the ``the whole graph'' should be placed
\emph{absolutely} once all relative positions have been computed. In
case that the graph consists of several unconnected components, the
situation is even more complicated.

In order to determine the absolute position of a graph, the graph
drawing engine relies on the following key:

\begin{key}{/graph drawing/desired at=\marg{coordinate}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  When you add this key to a node in a graph, you ``desire'' that the
  node should be placed at the \meta{coordinate} by the graph drawing
  algorithm. Now, when you set this key for a single node of a graph,
  then, by shifting the graph around, this ``wish'' can obviously
  always be fulfill:
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a [desired at={(1,0)}] -- b -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a -- b[desired at={(2,1)}] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [layered layout]
  {
    a -- b[desired at={(2,1)}] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
  Since the key's name is a but long and since the many braces and
  parentheses are a bit cumbersome, there is a special support for
  this key inside a |graph|: The standard |/tikz/at| key is redefined
  inside a |graph| so that it points to |/graph drawing/desired at|
  instead. (Which is more logical anyway, since it makes no sense to
  specify an |at| position for a node whose position it to be computed
  by a graph drawing algorithm.) A nice side effect of this is that
  you can use the |x| and |y| keys (see
  Section~\ref{section-graphs-xy}) to specify desired positions:
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a -- b[x=2,y=1] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [layered layout]
  {
    a [x=1,y=2] -- { b, c } -- {e, f} -- a
  };
\end{tikzpicture}
\end{codeexample}

  A problem arises when two or more nodes have this key set
  and when these nodes are in the same connected component, because
  then your ``desires'' for placement and the positions computed by
  the graph drawing algorithm may clash. Graph drawing algorithms are
  ``told'' about the desired positions. Most algorithms will simply
  ignore these desired positions since they will be taken care of in
  the so-called post-anchoring phase, see below. However, for some
  algorithms it makes a lot of sense to fix the positions of some
  nodes and only compute the positions 
  of the other nodes relative to these nodes. For instance, for a
  |spring layout| it makes perfect sense that some nodes are
  ``nailed to the canvas'' while other nodes can ``move freely''.
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f,g,h} };
  { h, g } -- a;
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d[x=0], e -- {f[x=2], g, h[x=1]} };
  { h, g } -- a;
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d[x=0], e -- {f[x=2,y=1], g, h[x=1]} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}


\begin{key}{/graph drawing/anchor node=\meta{node name}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This option can be used with a graph to specify a node that should
  be used for anchoring the whole graph. When this option is
  specified, after the layout has been computed, the whole graph will
  be shifted in such a way that the \meta{node name} is either
  \begin{itemize}
  \item at the current value of |anchor at| or 
  \item at the position that is specified in the form of a
    |desired at| for the \meta{node name}.
  \end{itemize}
\begin{codeexample}[]
\tikz \draw (0,0)
  -- (1,0.5) graph [edges=red,  layered layout, anchor node=a] { a -> {b,c} }
  -- (2,0)   graph [edges=blue, layered layout,
                    anchor node=y, anchor at={(2,0)}]          { x -> {y,z} };
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  
  \graph [layered layout, anchor node=c, edges=rounded corners]
    { a -- {b [x=1,y=1], c [x=1,y=1] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
  Note how in the above example |c| is placed at |(1,1)| rather than
  |b| as would happen by default.
\end{key}

\begin{key}{/graph drawing/anchor at=\meta{coordinate} (initially the origin)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  The coordinate at which the graph should be anchored when no
  explicit anchor is given for any node.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (2,2);
  
  \graph [layered layout, edges=rounded corners, anchor at={(1,2)}]
    { a -- {b, c [anchor here] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/anchor here=\opt{\meta{true or false}} (default true)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This option can be passed to a single node (rather than the graph as
  a whole) in order to specify that this node should be used for the
  anchoring process.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (2,2);
  
  \graph [layered layout, edges=rounded corners]
    { a -- {b, c [anchor here] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
  In the above example, |c| is placed at the origin since this is the
  default |anchor at| position.
\end{key}

Let us briefly summarize the order in which \tikzname\ tries to
determine the node at which the graph should be anchored:
\begin{enumerate}
\item If the |anchor node=|\meta{node name} option given to the graph
  as a whole, the graph is anchored at \meta{node name}, provided
  there is a node of this name in the graph. (If there is no node of
  this name or if it is mispelled, the effect is the same as if this
  option had not been given at all.)
\item Otherwise, if there is a node where the |anchor here| option is
  specified, the first node with this option set is used.
\item Otherwise, if there is a node where the |desired at| option is
  set (perhaps implicitly through keys like |x|), the first such node
  is used.
\item Finally, in all other cases, the first node is used.
\end{enumerate}

In the above description, the ``first'' node refers to the node first
encountered in the specification of the graph.



\subsection{Orienting a Graph}

\label{subsection-library-graphdrawing-standard-orientation}

Just as a graph drawing algorithm cannot know \emph{where} a graph
should be placed on a page, it is also often unclear which
\emph{orientation} it should have. Some graphs, like trees, have a
natural direction in which they ``grow'', but for an ``arbitrary''
graph the ``natural orientation'' is, well, arbitrary.

As for anchoring, the graph drawing algorithm is ``told'' about
the desired ``orientation of certain edges and certain nodes'': for
each node and each edge, keys may specify a ``desired
orientation''. For edges, you can, for instance, request that an
edge should be vertical an go upwards by saying |slope=up|. For a
node, ``specifying an orientation'' means that the rest of the graph
should be rotated in such a way that certain other nodes or
vectors should lie at a certain angle relative to the current node.


\subsubsection{Orienting a Graph by Fixing the Slope of Edges}

The following keys are used to specify orientations:
\begin{key}{/graph drawing/orient=\meta{angle}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Adding this key to an edge tells the graph drawing engine that the
  edge should have a slope of the given \meta{angle}. This ``slope''
  is defined as the angle of the line connecting the start of the edge
  to the end of the edge (independently of the actual to-path of the
  edge, which might define a bend or more complicated shapes). For
  instance, a \meta{angle} of |45| requests that the end node is ``up
  and right'' relative to the start node.
  
  Instead of an \meta{angle}, you can also specify the standard
  direction texts |north| or |south east| and so forth and also
  |up|, |down|, |left|, and |right|.
    
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f, g, h} };
  h -- [orient=30] a;
};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{angle}}
  Same as above, only the rest of the graph should be flipped relative
  to the edge.
    
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f, g, h} };
  h -- [orient'=30] a;
};
\end{codeexample}
\end{key}


\subsubsection{Orienting a Graph by Fixing the Slope Between Nodes}

\begin{key}{/graph drawing/orient=\opt{|:|}\meta{angle}|:|\meta{another node}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Adding this version of the |orient| key (it is detected by the
  presence of the colon) to a node requests that the graph drawing
  engine should ensure that the straight line from the origin (typically
  the center) of the node to the origin of \meta{another node}
  should have a slope of \meta{angle}. Note that the current node
  and the \meta{another node} need not be connected by an edge.
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=:-90:f] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
  
  Instead of an \meta{angle}, you can also specify the standard
  direction texts |north| or |south east| and so forth and also
  |up|, |down|, |left|, and |right|. Furthermore, the leading colon is
  optional: 
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=down:h] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}

  As special features, a dash somewhere inside the |orient| key is
  replaced by |:0:| and a vertical bar by |:-90:|. Thus, |orient=-a|
  is the same as |orient=:0:a|. Similarly:
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=|h] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{angle}:\meta{another node}}
  Same as above, only the rest of the graph should be flipped relative
  to the edge.
\end{key}

Instead of specifying the slope between two nodes ``at the nodes'' it 
is sometimes more natural to specify it at the beginning of the
graph. For this, the following special key is available:

\begin{key}{/graph drawing/orient=\meta{node1}|:|\meta{angle}|:|\meta{node2}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This has nearly the same effect as specifying
  |orient=|\meta{angle}|:|\meta{node2} as an option for the node
  \meta{node1}. The only difference is that |orient| options given at
  a node always take precedence over this ``global'' option.

  As above, \meta{node1}|-|\meta{node2} gets replaced by
  \meta{node1}|:0:|\meta{node2} and \meta{node1}\verb!|!\meta{node2}
  \meta{node1}|:-90:|\meta{node2}.
\begin{codeexample}[]
\tikz \graph [spring layout] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=a-b] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=b-a] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=b|a] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=a:10:b] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=1-2] { subgraph K_n[n=5] };
\tikz \graph [spring layout,orient=2-1] { subgraph K_n[n=5] };
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{orientation}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Does the same as |orient| except that the nodes are flipped over the
  principal axis.
\begin{codeexample}[]
\tikz \graph [spring layout,orient=a-b]  { a -- b -- c -- a };
\tikz \graph [spring layout,orient'=a-b] { a -- b -- c -- a };
\end{codeexample}
\end{key}



\subsubsection{Orienting a Graph by Fixing the Direction of Growth of the Children}

\begin{key}{/graph drawing/grow=\meta{angle}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This key specifies in which direction the neighbors of a node
  ``should grow.'' For some graph drawing algorithms, especially for
  those that layout trees, but also for those that produce layered
  layouts, there is a natural direction in which the ``children'' of
  a node should be placed. For instance, saying |grow=down| will cause
  the children of a node in a tree to be placed in a left-to-right
  line below the node (as always, you can replace the \meta{angle}
  by direction texts). The children are requested to be placed in a
  counter-clockwise fashion, the |grow'| key will place them in a
  clockwise fashion.
  
  Note that when you say |grow=down| it is not necessarily the case
  that any particular node is actually directly below the current
  node; the key just requests that the direction of growth is
  downward.
  
  In principle, you can specify the direction of growth for each node 
  individually, but do not count on graph drawing algorithms to
  honour these wishes.
  
\begin{codeexample}[]
\tikz \graph [layered layout, sibling distance=5mm]
{
  a [grow=right] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}

  When you give the |grow=right| key to the graph as a whole, it will
  be applied to all nodes. This happens to be exactly what you want:
  
\begin{codeexample}[]
\tikz \graph [layered layout, grow=right, sibling distance=5mm]
{
  a -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
  
\begin{codeexample}[]
\tikz
  \graph [layered layout, grow'=right]
  {
    {a,b,c} --[complete bipartite] {e,d,f}
            --[complete bipartite] {g,h,i};
  };
\end{codeexample}
\end{key}
  
\begin{key}{/graph drawing/grow'=\meta{angle}}
  Same as above, only with the children in clockwise order.
\begin{codeexample}[]
\tikz \graph [layered layout, sibling distance=5mm]
{
  a [grow'=right] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}



\subsubsection{The Phases of the Orientation Procedure}
\label{subsection-graph-orientation-phases}

As for anchoring a graph, the different keys for orienting graphs may
easily produce conflicting demands, which need to be
resolved:

\begin{enumerate}
\item
  The graph drawing algorithm is ``told'' about the desired
  orientations in the form of node and edge parameters. 
  An algorithm may or may not try to honor the desired
  orientations. As for the anchoring of graphs, for some algorithms it
  is natural and easy to restrict the way nodes are placed so as to
  honor orientation requests, for others this makes sense, at best, on
  a global scale. Algorithms will internally tell the graph drawing
  engine when they grow the graph in some direction. They can even
  indicate that they have already taken care of all growth demands for
  individual nodes. Nevertheless, the following steps are always
  performed:
\item
  It is now checked whether there is an edge in the graph whose
  slope has been fixed using the |orient| key. If there is at least one
  such edge, the first such edge is considered. The graph is rotated
  such that this edge has the desired slope. The orientation process
  stops at this point, all other orientation requests are ignored.
\item
  Otherwise, if there is no specified slope for any edge, it is
  checked whether there is a node with a specified |orient| to another
  node. If this is the case, the first such specification is taken for
  which the other node exists and the graph is rotated so that this
  orientation is satisfied. Again, the process stops in this case.
\item
  It is next checked whether there is a |orient| request for the graph
  as a whole like |orient=a-b|. Provided |a| and |b| exist, this
  request is honoured and the process stops.
\item
  If the algorithm has indicated that it has already taken care of all
  |grow| requests (using an internal function), the process stops at
  this point.
\item
  Otherwise, if none of the above cases is encountered, we look for
  a node with a |grow| key attached to it. If there is such a node,
  the graph is rotated so that the direction of growth of the graph is
  the desired growth direction. For this, the orientation procedure
  obviously needs to know what the direction of growth the algorithm
  was using; the algorithm signals this internally by setting the
  |growth_direction| of the algorithm object or by attaching a
  |growth_direction| to nodes. If an algorithm fails to attach such a
  direction, the direction of the first edge of the node is chosen
  and, for an isolated node, the direction is a line to the first node
  in the graph other than the current node.
  
  If no node has |grow| specified, the orientation is chosen in such a
  way as if |grow=down| had been specified for the first node of the
  graph.   
\end{enumerate}


%\subsection{Packing of Connected Components}

% Graphs may be composed of subgraphs or \emph{components} that are not
% connected to each other. In order to draw these nicely, the 
% |graphdrawing| library splits them up into separate graphs, computes
% their layouts with the same graph drawing algorithm independently and,
% in a postprocessing step, arranges them in a non-uniform grid in the 
% final drawing. This is called \emph{component packing}.

% The following options can be used to configure the order and placement
% strategy during component packing.

% \begin{key}{/graph drawing/component packing=\marg{options}}
%   \keyalias{tikz}\keyalias{tikz/graphs}
%   Executes the \meta{options} with the path prefix 
%   |/tikz/component packing|.
  
%   Defines how to arrange the connected components of the graph after 
%   their individual drawings have been computed.
% \end{key}

% To be written...

%\begin{key}{/tikz/component packing/layered=\opt{\meta{boolean}} (default true, initially true)}
%  |layered| arranges the different components in a non-uniform grid
%  starting in the top left corner. Components are placed in these 
%  layers in descending order of their size.
%  \begin{codeexample}[]
%\tikz \graph [experimental layout,component packing={layered}] {
%  a -- b -- c -- a,
%  d -- e -- d,
%  g
%};
%  \end{codeexample}
%\end{key}
%
%\begin{key}{/tikz/component packing/centered=\opt{\meta{boolean}} (default true, initially false)}
%  If set to |true|, arranges the different components clockwise in a 
%  non-uniform grid starting at the center. Components are placed in 
%  descending order of their size.
%  \begin{codeexample}[]
%\tikz \graph [experimental layout,component packing={centered}] {
%  a -- b -- c -- a,
%  d -- e -- d,
%  g
%};
%  \end{codeexample}
%\end{key}
%
%\begin{key}{/tikz/component packing/padding=\meta{dimension} (initially 0pt)}
%  Defines how much padding is used to separate the connected 
%  components.
%  \begin{codeexample}[]
%\tikz \graph [experimental layout,component packing={centered,padding=10pt}] {
%  a -- b -- c -- a,
%  d -- e -- d,
%  g
%};
%  \end{codeexample}
%\end{key}


\subsection{Implementing Graph Drawing Algorithms}

\label{section-gd-own-algorithm}
\label{section-library-graphdrawing-ownAlgorithm}

This section presents a simple example of how a graph drawing
algorithm can be implemented. A more detailed explanation of how
new graph drawing algorithms can be integrated and configured in given
in Section~\ref{section-gd-implementing-algorithms}.

As explained for the |algorithm| key, for each graph drawing algorithm
there must be a class of the name given to the |algorithm| key. This
class should usually reside in a file called
|pgfgd-algorithm-|\meta{algorithm name}. Each time a layout needs to
be computed for a graph, a new object of this graph is
instantiated. For this object, an attribute |graph| will be set to an
object representing the graph. Then, the |constructor| method of the
object is called, provided it exists. Then, the |run| method is
called, which should do the actual work. (The separation into a
constructor and a run method is purely for convenience.)
The |run| method should modify the coordinates of the nodes of its
|graph| attribute.

As a complete example, the following code fragment implements a
trivial graph drawing algorithm that just places all nodes on a
fixed-size circle.  It is accessed with the name 
|simple demo|, or |simple-demo| so both the file- and class name  
agree on that.

\pgfgddeclareforwardedkeys{/graph drawing}{
  radius/.graph parameter=evaluate math expression,
  radius/.parameter initial=1cm,
  node radius/.node parameter=evaluate math expression
}

\begin{codeexample}[code only]
-- File pgfgd-algorithm-SimpleDemo.lua
  
pgf.module("pgf.graphdrawing")

--- A trivial node placing algorithm for demonstration purposes.
-- All nodes are positioned on a fixed size circle.

SimpleDemo = {}
SimpleDemo.__index = SimpleDemo

function SimpleDemo:run()
   local radius = 28.908  -- this is 1cm in points
   local nodeCount = table.count_pairs(self.graph.nodes)

   local alpha = (2 * math.pi) / nodeCount
   local i = 0
   for node in table.value_iter(self.graph.nodes) do
      -- the interesting part...
      node.pos:set{x = radius * math.cos(i * alpha)}
      node.pos:set{y = radius * math.sin(i * alpha)}
      i = i + 1
   end
end
\end{codeexample}

The algorithm computes a circular layout like in the following.

\begin{codeexample}[]
\tikz [graph drawing scope, /graph drawing/algorithm=Simple Demo]
  \graph { f -> c -> e -> a -> {b -> {c, d, f}, e -> b}};
\end{codeexample}

For details on how to make things like |radius| configurable and how
to setup keys so that users can just write
|\tikz[circular layout] ...|, please see Section~\ref{section-gd-implementing-algorithms}.


\endinput

