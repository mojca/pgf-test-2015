% Copyright 2010 by RenÃ©e Ahrens, Olof Frahm, Jens Kluttig, Matthias Schulz, Stephan Schuster
% Copyright 2011 by Till Tantau
% Copyright 2011 by Jannis Pohlmann
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Using Algorithmic Graph Drawing}

{\noindent {\emph{by Till Tantau and Ren\'ee Ahrens, Olof-Joachim
      Frahm, Jens Kluttig, Jannis Pohlmann, Matthias Schulz, Stephan
      Schuster}}} 

\label{section-library-graphdrawing}

\begin{tikzlibrary}{graphdrawing}
  This package provides capabilities for automatic graph drawing.

  \medskip
  \textbf{Note:} Graph drawing requires that the document is typeset
  using Lua\TeX. This package should work with \LuaTeX\ 0.4 or
  higher, which is included in all current \TeX\ distributions.
\end{tikzlibrary}

\ifluatex\relax\else{LuaTeX is required for setting this manual
  section.}\expandafter\endinput\fi 


\subsection{Overview}

\emph{Algorithmic graph drawing} (or just \emph{graph drawing} in the
following) means that algorithms are used to decide where the nodes of
a graph are positioned on a page so that the graph ``looks nice.'' The
idea is that you, as human (or you, as a machine, if you happen to be
a machine and happen to be reading this document) just specify which
nodes are present in a graph and which edges are
present. Additionally, you may add some ``hints'' like ``this node
should be near the center'' or ``this edge is pretty important.'' You
do \emph{not} specify where, exactly, the nodes and edges should
be. This is something you leave to a \emph{graph drawing
  algorithm}. The algorithm gets your description of the graph as an
input and then decides where the nodes should go on the page.

Naturally, graph drawing is a bit of a (black?) art. There is no
``perfect'' way of drawing a graph, rather, depending on the
circumstances there are several different ways of drawing the same
graph and often it will just depend on the aesthetic sense of the
reader which layout he or she would prefer. For this reason, there is
a huge number of graph drawing algorithms ``out there'' and there are
scientific conference devoted to such algorithms, where each
year dozens of new algorithms are proposed.

Unlike the rest of \pgfname\ and \tikzname, which is implemented
purely in \TeX, the graph drawing algorithms are simply too complex to
implement them in \TeX. Instead, the programming language Lua is used
by the graph drawing library -- a programming language that has been
integrated into recent versions of \TeX. This means that (a) as a user
of the graph drawing engine you will can run \TeX\ on your documents
in the usual way, no external programs are called since Lua is already
integrated into \TeX\ and (b) it is pretty easy to implement new graph
drawing algorithms for \tikzname\ since Lua can be used and no \TeX\
programming knowledge is needed. 

The graph drawing engine of \tikzname\ provides two main features:
\begin{enumerate}
\item ``Users'' of the graph drawing engine can invoke the graph
  drawing algorithms often by just adding a single option to their
  picture. Here is a typical example, where the |layered layout| option
  tells \tikzname\ that the graph should be drawn (``should be layed
  out'') using a so-called ``layered graph drawing algorithm'' (what
  these are will be explained later):
\begin{codeexample}[]
\tikz
  \graph [layered layout, components go right top aligned, nodes={draw, rounded corners=2pt}]
  {
    first root -> {1 -> {2, 3} -> {4, 5}, 6 }, 4 -- 5;
    second root -> x -> {a -> {/,/}, b, c -> d -> {/,/} };
    third root -> child -> grandchild -> youngster -> third root;    
  };
\end{codeexample}
  Here is another example, where a different layout method is used
  that is more appropriate for trees:
\begin{codeexample}[]
\tikz [grow'=up, binary tree layout, nodes={circle,draw}]
  \node {1}
  child { node {2}
    child { node {3} }
    child { node {4}
      child { node {5} }
      child { node {6} }
    }
  }
  child { node {7}
    child { node {8}
      child[missing]
      child { node {9} }
    }
  };
\end{codeexample}
  An a final example, this time using a ``spring electrical layout''
  (whatever that might be\dots):
\begin{codeexample}[]
\tikz [spring electrical layout]
{
  \foreach \i in {1,...,6}
    \node (node \i) [fill=blue!50, text=white, circle] {\i};
    
  \draw (node 1) edge (node 2)
        (node 2) edge (node 3)
        (node 3) edge (node 4)
                 edge (node 5)
                 edge (node 6);
}
\end{codeexample}
  In all of the example, the positions of the nodes have only been
  computed \emph{after} all nodes have been created and the edges have
  been specified. For instance, in the last example, without the
  option |spring electrical layout|, all of the nodes would have been
  placed on top of each other.
\item The graph drawing engine is also intended to make is
  (relatively) easy to implement new graph drawing algorithms. These
  algorithms can and must be implemented in the Lua programming
  language (which is \emph{much} easier to program than \TeX\
  itself). The Lua code for a graph drawing algorithm gets an
  object-oriented model of the input graph as an input and must just
  compute the desired new positions of the nodes. The complete
  handling of passing options and configurations back-and-forth
  between the different \tikzname\ and \pgfname\ layers is handled by
  the graph drawing engine.

  The bottom line is that the graph drawing engine makes it easy
  to try out new graph drawing algorithms for medium sized graphs (up
  to a few hundred nodes).
\end{enumerate}

The documentation of the graph drawing engine is structured as
follows: The current section explains the graph drawing engine from
``the user's point of few'' and also describes the basic steps
necessary to implement a new graph drawing algorithm. The libraries
containing the different graph drawing algorithms are documented in
Sections on graph drawing
algorithms. Section~\ref{section-gd-own-algorithm} covers the
internals of how the graph drawing engine works. 



\subsection{Usage}

To use the graph drawing engine, you first need to load some
libraries. First, you should always load the |graphdrawing| library,
which will setup the basic keys. Next, you need to load another
library like |graphdrawing.trees|, see the following
Sections~\ref{section-first-graphdrawing-library-in-manual} to
\ref{section-last-graphdrawing-library-in-manual} for the different
libraries that are available. The actual graph drawing
algorithms reside in these libraries. Finally, you may also wish to
load the |graphs| library, but this is only necessary if you wish to
use the |graph| path command, which provides an easy-to-use syntax for
specifying graphs. You can also use the graph drawing engine
independently of the |graphs| library, for instance in conjunction
with the |child| or the |edge| syntax. Here is a typical setup:

\begin{codeexample}[code only]
\usetikzlibrary{graphs,graphdrawing,graphdrawing.trees}  
\end{codeexample}

Having setup things, you must then specify for which scopes the
graph drawing engine should apply an layout algorithm to the nodes in
the scope. Typically, you just add an option ending with |... layout|
to the |graph| path operation and then let the graph drawing do its
magic:

\begin{codeexample}[]
\tikz [rounded corners]
  \graph [layered layout, sibling distance=8mm, level distance=8mm]
  {
    a -> {
      b,
      c -> { d, e }
    } ->
    f -> 
    a
  };    
\end{codeexample}

Whenever you use such an option, (to be more precise, inside every
scope with the |graph drawing scope| key set either
explicitly or implicitly, which is exactly what happens when one such
an option is used) you can:
\begin{itemize}
\item Create nodes in the usual way. The nodes will be created
  completely, but then tucked away in an internal table. This means
  that all of \tikzname's options for nodes can be applied. You can
  also name a node and reference it later.
\item Create edges using either the syntax of the |graph| command
  (using |--|, |<-|, |->|, or |<->|), or using the |edge| command,
  or using the |child| command. These edges will, however, not be
  created immediately. Instead, the basic layer's command
  |\pgfgdedge| will be called, which stores ``all the information
  concerning the edge.'' The actual drawing of the edge will only
  happen after all nodes have been positioned.
\item Most of the keys that can be passed to an edge will work as
  expected. In particular, you can add labels to edges using the
  usual |node| syntax for edges.
\item The |label| and |pin| options can be used in the usual manner
  with nodes inside a graph drawing scope. Only, the labels and
  nodes will play no role in the positioning of the nodes and they
  are added when the nodes are finally positioned.
\item Similarly, nodes that are placed ``on an edge'' using the
  implicit positioning syntax can be used in the usual manner. 
\end{itemize}
Here are some things that will \emph{not} work:
\begin{itemize}
\item Only edges created using the graph syntax, the |edge| command,
  or the |child| command will correctly pass their connection
  information to the basic layer. When you write |\draw (a)--(b);|
  inside a graph drawing scope, where |a| and |b| are nodes that
  have been created inside the scope, you will get an error
  message / things will look wrong. The reason is that the usual
  |--| is not ``caught'' by the graph drawing engine and, thus,
  tries to immediately connect two nodes that do not yet exist
  (except inside some internal table).
\item The options of edges are executed twice: Once when the edge is
  ``examined'' by the |\pgfgdedge| command (using some magic to shield
  against the side effects) and then once more when the edge is
  actually created. Fortunately, in almost all cases, this will not be
  a problem; but if you do very evil magic inside your edge options,
  you must roll a D100 to see what strange things will happen. (Do no
  evil, by the way.)
\end{itemize}

The rest of this subsection describes the ``fine print'' of what
happens, in detail. You may wish to skip it.

\medskip
\noindent\textbf{The Details.}
Let us start with some background knowledge on how the graph drawing
engine works might be useful: Using a special internal key called
|graph drawing scope|, which you typically will not call directly,
the graph drawing engine can be switched on for a |{scope}|. When this
happens, a lot of things change inside \pgfname\ and \tikzname\ for
this scope: First, all nodes created inside the scope are not
immediately placed at the position where they were created. Instead,
they are ``spirited away'' to some internal table of the graph drawing
engine. Second, all edges created inside the scope using either the
|graph| command, the |edge| command, or the |child| command are also
``spirited away'' to another internal table. Then, at the end of the
scope, the graph drawing algorithm is started, which has access to
these internal tables of nodes and edge of the graph that has been
specified inside the scope. The algorithm will then compute new,
better, positions for the nodes. Finally, once the positions have been
computed, the graph drawing engine will then retrieve the nodes from
the internal table and place them at the computed positions and it
also retrieves the edges from the internal table and also adds them to
the picture.

While this theory may sound complicated, the use of the graph library
is, fortunately, pretty simple: Just add a key like |tree layout| or
|spring layout| to a scope and leave out any explicit positioning via
things like |at| -- the positioning will be done automatically by the
graph drawing algorithm.

The keys like |tree layout| or |spring layout| are explained in more detail
in the chapters on the different libraries. They all internally call
(at least) two keys: |graph drawing scope| and |algorithm|. These
keys are documented in the following, but you typically will not use
them explicitly. In addition to setting up the scope and setting the
correct algorithms, keys like |tree layout| and |spring layout| also take
some \meta{options} as arguments. These \meta{options} allow you setup
special graph parameters for the algorithm.

\begin{key}{/tikz/graph drawing scope}
  This key can (only) be used as an option when a \tikzname\ scope is
  started. Thus, you can pass it to |\tikz|, to |{tikzpicture}|, to
  |\scoped|, to |{scope}|, to |graph|, and to |{graph}|. For instance,
  the |tree layout| option (which uses |graph drawing scope| internally) can
  be used in the following ways:
\begin{codeexample}[]
\tikz [tree layout] \graph {a -> {b,c}};  

\tikz \graph [tree layout] {a -> {b,c}};

\tikz \path graph [tree layout] {a -> {b,c}};

\begin{tikzpicture}[tree layout]
  \graph {a -> {b,c}};
\end{tikzpicture}

\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,1);
  
  \scoped [tree layout] \graph {a -> {b,c}};
    
  \begin{scope}[tree layout, xshift=1cm, rotate=90]
    \graph {a -> {b,c}};
  \end{scope}
\end{tikzpicture}
\end{codeexample}

  You can \emph{not} use the |graph drawing scope| key with a single
  node or on a path. In particular, to typeset a tree given in the
  |child| syntax somewhere inside a |{tikzpicture}|, you must prefix
  it with the |\scoped| command:
\begin{codeexample}[]
\begin{tikzpicture}
  \scoped [tree layout]
    \node {root}
    child { node {left child} }
    child { node {right child} };
\end{tikzpicture}
\end{codeexample}
  Naturally, the above could have been written more succinctly as
\begin{codeexample}[]
\tikz [tree layout]
  \node {root}
  child { node {left child} }
  child { node {right child} };
\end{codeexample}
  Or even more succinctly:
\begin{codeexample}[]
\tikz \graph [tree layout] { root -- {left child, right child} };
\end{codeexample}

  In detail, adding the |graph drawing scope| command to a scope has
  the following effects:
  \begin{itemize}
  \item The basic layer is informed, using the
    |execute at begin scope| key, that the current scope will contain
    nodes that should be positioned by a graph drawing engine. Which
    algorithm is used depends on the value of the |algorithm| key.
  \item If the |graphs| library has been loaded, the default
    positioning mechanisms of this library are switched off, leaving
    the positioning to the graph drawing engine. Also, when an edge is
    created by the |graphs| library, this is signalled to the graph
    drawing library. (To be more precise: The keys |new ->| and so on
    are redefined so that they call |\pgfgdedge| instead of creating
    an edge.
  \item The |edge| path command is modified so that it also calls
    |\pgfgdedge| instead of immediately creating any edges.
  \item The |edge from parent| path command is modified so that is
    also calls |\pgfgdedge|.
  \item The keys |append after command| and |prefix after command|
    keys are modified so that they are executed only via
    |late options| when the node has ``reached its final parking
    position''. 
  \end{itemize}
\end{key}

\begin{key}{/graph drawing/algorithm=\meta{algorithm's name}}
  \label{section-gd-algorithm-key}%
  This key specifies which algorithm should be used for typesetting a
  graph. The names of these algorithm's are often a bit cryptic (like
  |Walshaw2000| or something similar), which is why you typically do
  not call this key directly. Instead, styles with more
  easy-to-remember names internally set this key.

  Setting this key has the following effects: When a scope with the
  |graph drawing scope| command is started, the current value of
  \meta{algorithm's name} is examined. Lua will try to find a class
  named \meta{algorithm's name} that has been declared using the
  |graph_drawing_algorithm| command (but any spaces inside the
  \meta{algorithm's name} are deleted). If it does not find such a
  class, the engine tries to  
  load the file called |pgfgd-algorithm-|\meta{algorithm's name}|.lua|
  (again, spaces are deleted) and then, again, tries to lookup the
  class. Thus, any class \meta{algorithm's name} mentioned inside a
  document must either have 
  already been defined in some Lua file loaded by some library or it
  must reside in a file with the corresponding name. Once the class
  has been found, the class's |new| method is called, the |graph|
  attribute of the object is set to the to-be-layouted graph, and the
  |constructor| method of the class is called for the object (if it
  exists) and, finally, the |run| method is called. Details of what
  should be done in these methods are given in
  Section~\ref{section-gd-own-algorithm}).  

  Here is an example where we switch on the graph drawing engine
  explicitly and explicitly select an algorithm:
\begin{codeexample}[]
\tikz [graph drawing scope,
       /graph drawing/algorithm=Spring Electrical Walshaw 2000]
  \graph { a <-> {b, c} };  
\end{codeexample}

  The reference of the available algorithms is in
  Sections~\ref{section-first-graphdrawing-library-in-manual} to 
  \ref{section-last-graphdrawing-library-in-manual}.
\end{key}




\subsection{Graph, Node, and Edge Parameters}

Graph drawing algorithms can typically be configured in some way. For
instance, for a graph drawing algorithm that visualizes its nodes as a
tree, it will typically be useful when the user can change the
so-called \emph{level distance} and the \emph{sibling distance}. For
other algorithms, like force-based algorithms, a large number of
parameters influence the way the algorithms work.

Options that influence graph drawing algorithms will be called
\emph{graph drawing parameters} in the following. There are three kinds of
graph drawing parameters:
\begin{itemize}
\item Graph parameters,
\item node parameters, and
\item edge parameters.
\end{itemize}
A graph drawing graph parameter influences the layout of the whole
graph. A graph drawing node parameter is an option that is attached to
a single node and should only have a direct influence on this node
(like ``place this node exactly at this position, no matter what''). A
graph drawing edge parameter in important for a single edge (like
``this edge must be exactly |2cm| long'').

A graph drawing algorithm may or may not take the different graph
parameters into account. After all, these options may even outright
contradict each other, so an algorithm can only try to ``do its
best''.

While many graph parameters are very specific to a single algorithm, a
number of graph parameters will be important for many algorithms. Such
graph parameters are called \emph{common} graph parameters, the most
important of which are documented in the following. The common graph
parameters can be used like any normal \tikzname\ option. In contrast,
specific options for algorithms must be passed to the key that
installs the algorithm. For example, the orientation of a graph
is setup with the common key |orient|, which is given alongside a key
like |spring layout|:

\begin{codeexample}[]
\tikz \graph [spring layout, orient=1|2] { 1--2--3--1 };  
\end{codeexample}

In contrast, the very specific option |iterations| must be
passed to the |spring layout| key:

\begin{codeexample}[]
\tikz \graph [spring layout={iterations=3}] { 1--2--3--1 };  
\end{codeexample}





\subsection{Padding and Node Distances}

\label{subsection-gd-dist-pad}

In many drawings, you may wish to specify how ``near'' two nodes should
be placed by a graph drawing algorithm. Naturally, this depends
strongly on the specifics of the algorithm, but there are a number of
general keys that will be used by many algorithms.



\subsubsection{Distances and Paddings Between Layers}

A number of graph drawing algorithms arrange nodes in layers; we refer
to the nodes on the same layer as siblings (although, in a tree,
siblings are only nodes with the same parent; nevertheless we use
``sibling'' loosely also for nodes that are more like ``cousins'').

\begin{key}{/graph drawing/level distance=\meta{dimension} (initially 1cm)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is minimum distance that the centers of nodes on one
  level should have from the centers of nodes on the next level. It
  will not always be possible to satisfy this desired distance, for
  instance in case the nodes are too big. In this case, the
  \meta{dimension} is just considered as a lower bound.
\begin{codeexample}[]
\tikz \graph [layered layout, level distance=1cm] { 1--2--3--1 };  
\tikz \graph [layered layout, level distance=5mm] { 1--2--3--1 };  
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/level pre sep=\meta{dimension} (initially 0.5pt)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is a minimum ``padding'' or ``separation'' between the border
  of the nodes on a level to any nodes on the previous level. Thus, if
  nodes are so big that nodes on consecutive levels would overlap (or
  just come with \meta{dimension} distance of one another), their
  distance is enlarged so that this distance is still satisfied.

  (If a node on the previous level also has a |level post sep|, this
  post padding and the \meta{dimension} add up. Thus, these keys
  behave like the ``padding'' keys rather
  than the ``margin'' key of cascading style sheets.)
  
  Currently, this option is not yet implemented.
\end{key}

\begin{key}{/graph drawing/level post sep=\meta{dimension} (initially 0.5pt)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Works like |level pre sep|.
\end{key}

\begin{key}{/graph drawing/level sep=\meta{dimension}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Sets both |level pre sep| and |level post sep| to
  $\meta{dimension}/2$.
\end{key}

Note that if you set |level distance=0| and |level distance=1em|, you get
a layout where any two consecutive layers are ``spaced apart'' by
|1em|.


\subsubsection{Distances and Paddings Between Siblings}

The following keys work much like the |level ...| keys, only for
sibling:

\begin{key}{/graph drawing/sibling distance=\meta{dimension} (initially 1cm)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is minimum distance that the centers of node should have to the
  center of the next node on the same level. As for levels, this is
  just a lower bound.

  For some layouts, like a circular layout, the \meta{dimension} is
  measured as the distance on the circle:
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=1cm, nodes={circle,draw}]
  { 1--2--3--4--5--6--1 };  
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=0cm, sibling sep=0pt,
              nodes={circle,draw}]
  { 1--2--3--4--5--6--1 };  
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=0cm, sibling sep=0pt,
              nodes={circle,draw}]
  { 1--2--3[sibling distance=3cm]--4--5--6--1 };  
\end{codeexample}
\end{key}


\begin{key}{/graph drawing/sibling pre sep=\meta{dimension} (initially 0.5pt)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Works like |level pre sep|, only for siblings.
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=0cm, nodes={circle,draw},
              sibling sep=0pt]
  { 1--2--3--4--5--6--1 };  
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=0cm, nodes={circle,draw},
              sibling pre sep=1em]
  { 1--2--3--4--5--6--1 };  
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [circular layout, sibling distance=0cm, nodes={circle,draw},
              sibling pre sep=1em]
  { 1--2--3[sibling pre sep=1cm]--4--5--6--1 };  
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/level sibling sep=\meta{dimension} (initially 0.5pt)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Works like |level sibling sep|.
\end{key}

\begin{key}{/graph drawing/sibling sep=\meta{dimension}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Sets both |sibling pre sep| and |sibling post sep| to
  $\meta{dimension}/2$.
\end{key}




\subsubsection{Paddings Between Components}

When a graph consists of several connected component, many graph
drawing algorithms will layout these components individually. The
different components will then be arranged next to each other, see
Section~\ref{section-gd-packing} for the details, such that between
the nodes of any two components the following padding is avaiable:

\begin{key}{/graph drawing/component sep=\meta{dimension} (initially 2em)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This is distance between the bounding boxes that nodes of different
  connected components will have when they are placed next to each
  other:
\begin{codeexample}[]
\tikz \graph [binary tree layout, sibling distance=4mm, level distance=8mm,
              components go right top aligned,
              component sep=1pt, nodes=draw]  
{
  1 -> 2 -> {3->4[second]->5,6,7};
  a -> b[second] -> c[second] -> d -> e;
  x -> y[second] -> z -> u[second] -> v;
};  
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, sibling distance=4mm, level distance=8mm,
              components go right top aligned,
              component sep=1em, nodes=draw]  
{
  1 -> 2 -> {3->4[second]->5,6,7};
  a -> b[second] -> c[second] -> d -> e;
  x -> y[second] -> z -> u[second] -> v;
};  
\end{codeexample}
\end{key}



\subsection{Anchoring a Graph}

\label{subsection-library-graphdrawing-anchoring}

A graph drawing algorithm must compute positions of the nodes of a
graph, but the computed positions are only \emph{relative} (``this
node is left of this node, but above that other node''). It is not
immediately obvious where the ``the whole graph'' should be placed
\emph{absolutely} once all relative positions have been computed. In
case that the graph consists of several unconnected components, the
situation is even more complicated.

In order to determine the absolute position of a graph, the graph
drawing engine relies on the following key:

\begin{key}{/graph drawing/desired at=\marg{coordinate}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  When you add this key to a node in a graph, you ``desire'' that the
  node should be placed at the \meta{coordinate} by the graph drawing
  algorithm. Now, when you set this key for a single node of a graph,
  then, by shifting the graph around, this ``wish'' can obviously
  always be fulfill:
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a [desired at={(1,0)}] -- b -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a -- b[desired at={(2,1)}] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [layered layout]
  {
    a -- b[desired at={(2,1)}] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
  Since the key's name is a but long and since the many braces and
  parentheses are a bit cumbersome, there is a special support for
  this key inside a |graph|: The standard |/tikz/at| key is redefined
  inside a |graph| so that it points to |/graph drawing/desired at|
  instead. (Which is more logical anyway, since it makes no sense to
  specify an |at| position for a node whose position it to be computed
  by a graph drawing algorithm.) A nice side effect of this is that
  you can use the |x| and |y| keys (see
  Section~\ref{section-graphs-xy}) to specify desired positions:
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [spring layout]
  {
    a -- b[x=2,y=1] -- c -- a;
  };
\end{tikzpicture}
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \graph [layered layout]
  {
    a [x=1,y=2] -- { b, c } -- {e, f} -- a
  };
\end{tikzpicture}
\end{codeexample}

  A problem arises when two or more nodes have this key set
  and when these nodes are in the same connected component, because
  then your ``desires'' for placement and the positions computed by
  the graph drawing algorithm may clash. Graph drawing algorithms are
  ``told'' about the desired positions. Most algorithms will simply
  ignore these desired positions since they will be taken care of in
  the so-called post-anchoring phase, see below. However, for some
  algorithms it makes a lot of sense to fix the positions of some
  nodes and only compute the positions 
  of the other nodes relative to these nodes. For instance, for a
  |spring layout| it makes perfect sense that some nodes are
  ``nailed to the canvas'' while other nodes can ``move freely''.
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f,g,h} };
  { h, g } -- a;
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d[x=0], e -- {f[x=2], g, h[x=1]} };
  { h, g } -- a;
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d[x=0], e -- {f[x=2,y=1], g, h[x=1]} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}


\begin{key}{/graph drawing/anchor node=\meta{node name}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This option can be used with a graph to specify a node that should
  be used for anchoring the whole graph. When this option is
  specified, after the layout has been computed, the whole graph will
  be shifted in such a way that the \meta{node name} is either
  \begin{itemize}
  \item at the current value of |anchor at| or 
  \item at the position that is specified in the form of a
    |desired at| for the \meta{node name}.
  \end{itemize}
\begin{codeexample}[]
\tikz \draw (0,0)
  -- (1,0.5) graph [edges=red,  layered layout, anchor node=a] { a -> {b,c} }
  -- (2,0)   graph [edges=blue, layered layout,
                    anchor node=y, anchor at={(2,0)}]          { x -> {y,z} };
\end{codeexample}
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  
  \graph [layered layout, anchor node=c, edges=rounded corners]
    { a -- {b [x=1,y=1], c [x=1,y=1] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
  Note how in the above example |c| is placed at |(1,1)| rather than
  |b| as would happen by default.
\end{key}

\begin{key}{/graph drawing/anchor at=\meta{coordinate} (initially the origin)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  The coordinate at which the graph should be anchored when no
  explicit anchor is given for any node.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (2,2);
  
  \graph [layered layout, edges=rounded corners, anchor at={(1,2)}]
    { a -- {b, c [anchor here] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/anchor here=\opt{\meta{true or false}} (default true)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This option can be passed to a single node (rather than the graph as
  a whole) in order to specify that this node should be used for the
  anchoring process.
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (2,2);
  
  \graph [layered layout, edges=rounded corners]
    { a -- {b, c [anchor here] } -- d -- a};
\end{tikzpicture}
\end{codeexample}
  In the above example, |c| is placed at the origin since this is the
  default |anchor at| position.
\end{key}

Let us briefly summarize the order in which \tikzname\ tries to
determine the node at which the graph should be anchored:
\begin{enumerate}
\item If the |anchor node=|\meta{node name} option given to the graph
  as a whole, the graph is anchored at \meta{node name}, provided
  there is a node of this name in the graph. (If there is no node of
  this name or if it is mispelled, the effect is the same as if this
  option had not been given at all.)
\item Otherwise, if there is a node where the |anchor here| option is
  specified, the first node with this option set is used.
\item Otherwise, if there is a node where the |desired at| option is
  set (perhaps implicitly through keys like |x|), the first such node
  is used.
\item Finally, in all other cases, the first node is used.
\end{enumerate}

In the above description, the ``first'' node refers to the node first
encountered in the specification of the graph.



\subsection{Orienting a Graph}

\label{subsection-library-graphdrawing-standard-orientation}

Just as a graph drawing algorithm cannot know \emph{where} a graph
should be placed on a page, it is also often unclear which
\emph{orientation} it should have. Some graphs, like trees, have a
natural direction in which they ``grow'', but for an ``arbitrary''
graph the ``natural orientation'' is, well, arbitrary.

As for anchoring, the graph drawing algorithm is ``told'' about
the desired ``orientation of certain edges and certain nodes'': for
each node and each edge, keys may specify a ``desired
orientation''. For edges, you can, for instance, request that an
edge should be vertical an go upwards by saying |slope=up|. For a
node, ``specifying an orientation'' means that the rest of the graph
should be rotated in such a way that certain other nodes or
vectors should lie at a certain angle relative to the current node.


\subsubsection{Orienting a Graph by Fixing the Slope of Edges}

The following keys are used to specify orientations:
\begin{key}{/graph drawing/orient=\meta{angle}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Adding this key to an edge tells the graph drawing engine that the
  edge should have a slope of the given \meta{angle}. This ``slope''
  is defined as the angle of the line connecting the start of the edge
  to the end of the edge (independently of the actual to-path of the
  edge, which might define a bend or more complicated shapes). For
  instance, a \meta{angle} of |45| requests that the end node is ``up
  and right'' relative to the start node.
  
  Instead of an \meta{angle}, you can also specify the standard
  direction texts |north| or |south east| and so forth and also
  |up|, |down|, |left|, and |right|.
    
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f, g, h} };
  h -- [orient=30] a;
};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{angle}}
  Same as above, only the rest of the graph should be flipped relative
  to the edge.
    
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a -- { b, c, d, e -- {f, g, h} };
  h -- [orient'=30] a;
};
\end{codeexample}
\end{key}


\subsubsection{Orienting a Graph by Fixing the Slope Between Nodes}

\begin{key}{/graph drawing/orient=\opt{|:|}\meta{angle}|:|\meta{another node}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Adding this version of the |orient| key (it is detected by the
  presence of the colon) to a node requests that the graph drawing
  engine should ensure that the straight line from the origin (typically
  the center) of the node to the origin of \meta{another node}
  should have a slope of \meta{angle}. Note that the current node
  and the \meta{another node} need not be connected by an edge.
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=:-90:f] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
  
  Instead of an \meta{angle}, you can also specify the standard
  direction texts |north| or |south east| and so forth and also
  |up|, |down|, |left|, and |right|. Furthermore, the leading colon is
  optional: 
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=down:h] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}

  As special features, a dash somewhere inside the |orient| key is
  replaced by |:0:| and a vertical bar by |:-90:|. Thus, |orient=-a|
  is the same as |orient=:0:a|. Similarly:
\begin{codeexample}[]
\tikz \graph [spring layout]
{
  a [orient=|h] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{angle}:\meta{another node}}
  Same as above, only the rest of the graph should be flipped relative
  to the edge.
\end{key}

Instead of specifying the slope between two nodes ``at the nodes'' it 
is sometimes more natural to specify it at the beginning of the
graph. For this, the following special key is available:

\begin{key}{/graph drawing/orient=\meta{node1}|:|\meta{angle}|:|\meta{node2}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This has nearly the same effect as specifying
  |orient=|\meta{angle}|:|\meta{node2} as an option for the node
  \meta{node1}. The only difference is that |orient| options given at
  a node always take precedence over this ``global'' option.

  As above, \meta{node1}|-|\meta{node2} gets replaced by
  \meta{node1}|:0:|\meta{node2} and \meta{node1}\verb!|!\meta{node2}
  \meta{node1}|:-90:|\meta{node2}.
\begin{codeexample}[]
\tikz \graph [spring layout] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=a-b] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=b-a] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=b|a] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=a:10:b] { a -- b -- c -- a };
\tikz \graph [spring layout,orient=1-2] { subgraph K_n[n=5] };
\tikz \graph [spring layout,orient=2-1] { subgraph K_n[n=5] };
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/orient'=\meta{orientation}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  Does the same as |orient| except that the nodes are flipped over the
  principal axis.
\begin{codeexample}[]
\tikz \graph [spring layout,orient=a-b]  { a -- b -- c -- a };
\tikz \graph [spring layout,orient'=a-b] { a -- b -- c -- a };
\end{codeexample}
\end{key}



\subsubsection{Orienting a Graph by Fixing the Direction of Growth of the Children}

\begin{key}{/graph drawing/grow=\meta{angle}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  This key specifies in which direction the neighbors of a node
  ``should grow.'' For some graph drawing algorithms, especially for
  those that layout trees, but also for those that produce layered
  layouts, there is a natural direction in which the ``children'' of
  a node should be placed. For instance, saying |grow=down| will cause
  the children of a node in a tree to be placed in a left-to-right
  line below the node (as always, you can replace the \meta{angle}
  by direction texts). The children are requested to be placed in a
  counter-clockwise fashion, the |grow'| key will place them in a
  clockwise fashion.
  
  Note that when you say |grow=down| it is not necessarily the case
  that any particular node is actually directly below the current
  node; the key just requests that the direction of growth is
  downward.
  
  In principle, you can specify the direction of growth for each node 
  individually, but do not count on graph drawing algorithms to
  honour these wishes.
  
\begin{codeexample}[]
\tikz \graph [layered layout, sibling distance=5mm]
{
  a [grow=right] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}

  When you give the |grow=right| key to the graph as a whole, it will
  be applied to all nodes. This happens to be exactly what you want:
  
\begin{codeexample}[]
\tikz \graph [layered layout, grow=right, sibling distance=5mm]
{
  a -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
  
\begin{codeexample}[]
\tikz
  \graph [layered layout, grow'=right]
  {
    {a,b,c} --[complete bipartite] {e,d,f}
            --[complete bipartite] {g,h,i};
  };
\end{codeexample}
\end{key}
  
\begin{key}{/graph drawing/grow'=\meta{angle}}
  Same as above, only with the children in clockwise order.
\begin{codeexample}[]
\tikz \graph [layered layout, sibling distance=5mm]
{
  a [grow'=right] -- { b, c, d, e -- {f, g, h} };
  { h, g } -- a;
};
\end{codeexample}
\end{key}



\subsubsection{The Phases of the Orientation Procedure}
\label{subsection-graph-orientation-phases}

As for anchoring a graph, the different keys for orienting graphs may
easily produce conflicting demands, which need to be
resolved. The following steps are normally performed for each
connected component of the graph independently (see 
Section~\ref{section-gd-packing} for details on connected components),
but algorithms may choose to consider the graph ``as a whole''. In
this case, the following steps are performed only once for the whole
graph. 

\begin{enumerate}
\item
  The graph drawing algorithm is ``told'' about the desired
  orientations in the form of graph, node, and edge parameters. 
  An algorithm may or may not try to honor the desired
  orientations. As for the anchoring of graphs, for some algorithms it
  is natural and easy to restrict the way nodes are placed so as to
  honor orientation requests, for others this makes sense, at best, on
  a global scale. Algorithms will internally tell the graph drawing
  engine when they grow the graph in some direction. They can even
  indicate that they have already taken care of all growth demands for
  individual nodes.

  Nevertheless, the following steps are always performed:
\item
  The engine checks whether there is an edge in the graph whose
  slope has been fixed using the |orient| key. If there is at least one
  such edge, the first such edge is considered. The graph is rotated
  such that this edge has the desired slope. The orientation process
  stops at this point, all other orientation requests are ignored.
\item
  Otherwise, if there is no specified slope for any edge, it is
  checked whether there is a node with a specified |orient| to another
  node. If this is the case, the first such specification is taken for
  which the other node exists and the graph is rotated so that this
  orientation is satisfied. Again, the process stops in this case.
\item
  It is next checked whether there is a |orient| request for the graph
  as a whole like |orient=a-b|. Provided |a| and |b| exist, this
  request is honoured and the process stops.
\item
  If the algorithm has indicated that it has already taken care of all
  |grow| requests (using an internal function), the process stops at
  this point.
\item
  Otherwise, if none of the above cases is encountered, we look for
  a node with a |grow| key attached to it. If there is such a node,
  the graph is rotated so that the direction of growth of the graph is
  the desired growth direction. For this, the orientation procedure
  obviously needs to know what the direction of growth the algorithm
  was using; the algorithm signals this internally by setting the
  |growth_direction| of the algorithm object or by attaching a
  |growth_direction| to nodes. If an algorithm fails to attach such a
  direction, the direction of the first edge of the node is chosen
  and, for an isolated node, the direction is a line to the first node
  in the graph other than the current node.
  
  If no node has |grow| specified, the orientation is chosen in such a
  way as if |grow=down| had been specified for the first node of the
  graph.   
\end{enumerate}



\subsection{Packing of Connected Components}

\label{subsection-gd-component-packing}

Graphs may be composed of subgraphs or \emph{components} that are not
connected to each other. In order to draw these nicely, most graph
drawing algorithms split them into separate graphs, computes
their layouts with the same graph drawing algorithm independently and,
in a postprocessing step, arranges them next to each other. (Some
graph drawing algorithms will treat a graph ``as a whole''; for such
algorithms the following options do not apply.)

The default method for placing the different components works as
follows:

\begin{enumerate}
\item For each component, a layout is determined and the component is
  oriented as described
  Section~\ref{subsection-library-graphdrawing-standard-orientation}
  on orientation of graphs. 
\item Then, we differentiate between two kinds of components: Those
  that contain an anchored node and those that do not. As described in
  Section~\ref{subsection-library-graphdrawing-anchoring}, you can
  directly specify for a node where it should be placed on the
  page. If a component contains such a node, it is clear where the
  component should go (we call it ``anchored'').
  
  The packing collects and considers all unanchored nodes, plus the
  first anchored component, if such a component exists. The second and
  further anchored component are not considered during the packing
  process, they are simply anchored according to their anchor nodes. 
\item If the previous step has yielded two or more components that now
  need to be packed, they are sorted as prescribed by the
  |component order| key.
\item The first component is now placed (conceptually) at the
  origin. (The final position of this and all other components will be
  determined later, namely in the anchoring phase, but let us imagine
  that the first component lies at the origin at this point.)
\item The second component is now positioned relative to the first
  component. The ``direction'' in which the next component is placed
  relative to the first one is determined by the |component direction|
  key, so components can be placed from left to right or up to down or
  even in any angular direction. However, both internally and in the
  following description, we assume that the components are placed from
  left to right; other directions are achieved by doing some (clever)
  rotating of the arrangement achieved in this way.

  So, we now wish to place the second component to the right of the
  first component. The component is first shifted vertically according
  to some alignment strategy. For instance, it can be shifted so that
  the topmost node of the first component and the topmost node of the
  second component have the same vertical position. Alternatively, we
  might require that certain ``alignment nodes'' in both components
  have the same vertical position. There are several other strategies,
  which can be configured using the |component align| key.

  One the vertical position has been fixed, the horizontal position is
  computed. Here, two different strategies are available: First, image
  rectangular bounding boxed to be drawn around both components. Then
  we shift the second component such that the right border of the
  bounding box of the first component touches the left border of the
  bounding box of the second component. Instead of having the bounding
  boxes ``touch,'' we can also have a padding of |component sep|
  between them. The second strategy is more involved and also known as
  a ``skyline'' strategy. It works as follows: Imaging the second
  component to be placed far to the right of the first component. Now
  start moving the second component to the left until one of the nodes
  of the second component touches a node of the first component, and
  stop. Again, the padding |component sep| can be used to avoid the
  nodes actually touching each other. (In case you are worried that
  the second component might actually ``pass through'' the first
  component because the nodes of the two component have totally
  different vertical heights, rest assured, that such ``vertical
  holes'' are taken care of to avoid this case.)
\item
  After the second component has been placed, the third component is
  considered and positioned relative to the second one, and so on.
\item
  At the end, as hinted at earlier, the whole arrangement is rotate so
  that instead of ``going right'' the component go in the direction of
  |component direction|. Note, however, the this rotation applies only
  to the ``shift'' of the components; the components themselves are
  not rotated. Fortunately, this whole rotation process happens in the
  background and the result is normally exactly what you would expect.
\end{enumerate}

In the following, we go over the different keys that can be used to
configure the component packing.


\subsubsection{Ordering the Component}

The different connected components of the graph are collected in a
list. The ordering of the nodes in this list can be configured using
the following key:

\begin{key}{/graph drawing/component order=\meta{strategy} (initially
    by first specified node)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  The following values are permissible for \meta{strategy}
  \begin{itemize}
  \item \declare{|by first specified node|}

    The components are ordered ``in the way they appear in the input
    specification of the graph''. More precisely, for each component
    consider the node that is first encountered in the description
    of the graph. Order the components in the same way as these nodes
    appear in the graph description.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle}]
{ a, b, c -- d -- e, f -- g };
\end{codeexample}
  \item \declare{|increasing node number|}
    
    The components are ordered by increasing number of nodes. For
    components with the same number of nodes, the first node in each
    component is considered and they are ordered according to the
    sequence in which these nodes appear in the input.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle},
              component order=increasing node number]
{ a, b, c -- d -- e, f -- g };
\end{codeexample}
    \begin{key}{/graph drawing/small components first}
      \keyalias{tikz}
      \keyalias{tikz/graphs}
      A shorthand for |component order=increasing node number|.
    \end{key}
  \item \declare{|decreasing node number|}
    As above, on in decreasing order.  
    \begin{key}{/graph drawing/large components first}
      \keyalias{tikz}
      \keyalias{tikz/graphs}
      A shorthand for |component order=decreasing node number|.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle},
              large components first]
{ a, b, c -- d -- e, f -- g };
\end{codeexample}
    \end{key}
  \end{itemize}
\end{key}


\subsubsection{Arranging Components in a Certain Direction}

\begin{key}{/graph drawing/component direction=\meta{angle} (initially 0)}
  \keyalias{tikz}\keyalias{tikz/graphs}
  The \meta{angle} is used to determine the relative position of each
  component relative to the previous one. The direction need not be a
  multiple of |90|.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle},
              component direction=left]
  { a, b, c -- d -- e, f -- g };
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle},
              component direction=10]
  { a, b, c -- d -- e, f -- g };
\end{codeexample}
  As usual, you can use texts like |up| or |right| instead of a
  number.

  As the example shows, the direction only has an influence on the
  relative positions of the components, not on the direction of growth
  inside the components. In particular, the components are not rotated
  by this option in any way. You can use the |grow| option or |orient|
  options to orient individual components:
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={inner sep=1pt,draw,circle},
              component direction=up]
  { a, b, c [grow=right] -- d -- e, f[grow=45] -- g };
\end{codeexample}
\end{key}



\subsubsection{Aligning Components}

When components are placed next to each from left to right, it
is not immediately clear how the components should be aligned
vertically. What happens is the in each component a horizontal line is
determined and then all components are shifted vertically so that the
lines are aligned. There are different strategies for choosing these
``lines'', see the description of the options described later on.
When the |component direction| option is used to change the direction
in which components are placed, it certainly make no longer sense to
talk about ``horizontal'' and ``vertical'' lines. Instead, what
actually happens is that the alignment does not consider
``horizontal'' lines, but lines that go in the direction specified by
|component direction| and aligns them by moving components along a
line that is perpendicular to the line. For these reasons, let us call
the line in the component direction the \emph{alignment line} and a
line that is perpendicular to it the \emph{shift line}.

The first way of specifying through which point of a component the
alignment line should get is to use the following option:

\begin{key}{/graph drawing/align here}
  \keyalias{tikz}
  \keyalias{tikz/graphs}
  When this option is given to a node, this alignment line will go
  through the origin of this node. If this option is passed to more
  than one node of a component, the node encountered first in the
  component is used.
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw}]
{ a, b -- c[align here], d -- e[second, align here] -- f };
\end{codeexample}
\end{key}

In many cases, however, you will not wish to specify an alignment node
manually in each component. Instead, you will use the following key to
specify a \emph{strategy} that should be used to automatically
determine such a node:

\begin{key}{/graph drawing/component align=\meta{strategy} (initially first node)}
  \keyalias{tikz}
  \keyalias{tikz/graphs}
  The following values are permissible:
  \begin{itemize}
  \item \declare{|first node|}
    In each component, the alignment line goes through the center of
    the first node of the component encountered during specification
    of the component.
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component align=first node]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
  \item \declare{|center|}
    
    The nodes of the component are projected onto the shift line. The
    alignment line is now chosen so that is exactly in the middle
    between the maximum and minimum value that the projected nodes
    have on the shift line.
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component align=center]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component direction=90,
              component align=center]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
  \item \declare{|counterclockwise|}

    As for |center|, we project the nodes of the component onto the
    shift line. The alignment line is now chosen so that it goes
    through the center of the node whose center has the highest
    projected value.
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component align=counterclockwise]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component direction=90,
              component align=counterclockwise]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
    The name |counterclockwise| is intended to indicate that the align
    line goes through the node that comes last if we go from the
    alignment direction in a counter-clockwise direction.
  \item \declare{|clockwise|}
    
    Works like |counterclockwise|, only in the other direction:
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component align=clockwise]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, nodes={draw},
              component direction=90,
              component align=clockwise]
{ a, b -- c, d -- e[second] -- f };
\end{codeexample}
  \item \declare{|counterclockwise bounding box|}

    This method is quite similar to |counterclockwise|, only the
    alignment line does not go through the center of the node with a
    maximum projected value on the shift line, but through the maximum
    value of the projected bounding boxes. For a left-to-right
    packing, this means that the components are aligned so that the
    bounding boxes of the components are aligned at the top.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw, align=center},
              component align=counterclockwise]
{ a, "high\\node" -- b};
\tikz \graph [tree layout, nodes={draw, align=center},
              component align=counterclockwise bounding box]
{ a, "high\\node" -- b};
\end{codeexample}
  \item \declare{|clockwise bounding box|}
    
    Works like |counterclockwise bounding box|.
  \end{itemize}
\end{key}

Using a combination of |component direction| and |component align|,
numerous different packing strategies can be configured. However,
since names like |counterclockwise| are a bit hard to remember and to
apply in practice, a number of easier-to-remember keys are predefined
that combine an alignment and a direction:

\begin{key}{/graph drawing/components go right top aligned}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
  Shorthand for |component direction=right| and
  |component align=counterclockwise|. This means that, as the name
  suggest, the components will be placed left-to-right and they are
  aligned such that their top nodes are in a line.  
\begin{codeexample}[]  
\tikz \graph [tree layout, nodes={draw, align=center},
              components go right top aligned]
  { a, "high\\node" -- b};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/components go right absolute top aligned}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
  Like the previous key, but with
  |component align=counterclockwise bounding box|. This means that the
  components will be aligned with their bounding boxed being
  top-aligned: 
\begin{codeexample}[]  
\tikz \graph [tree layout, nodes={draw, align=center},
              components go right absolute top aligned]
  { a, "high\\node" -- b};
\end{codeexample}
\end{key}

\begin{key}{/graph drawing/components go right bottom aligned}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
  As above, only with an alignment of the bottom nodes.
\end{key}

\begin{key}{/graph drawing/components go right absolute bottom aligned}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
\end{key}

\begin{key}{/graph drawing/components go right center aligned}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
  As above, but with the alignment at the centers.
\end{key}

\begin{key}{/graph drawing/components go right}
  \keyalias{tikz/graphs}
  \keyalias{tikz}
  Shorthand for |component direction=right| and
  |component align=first node|.
\end{key}

The above options are all available also with |right| replaced by
|left|. Here is an example:
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw, align=center},
              components go left top aligned]
  { a, "high\\node" -- b};
\end{codeexample}
Next, the options are also available with |right| replaced by |up| and
also by |down|. Then, instead of |top| or |bottom| for the alignment,
|left| and |right| must be used:
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw, align=center},
              components go down left aligned]
  { a, hello -- {world,s} };
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw, align=center},
              components go up absolute left aligned]
  { a, hello -- {world,s}};
\end{codeexample}



\subsubsection{The Distance Between Components}

Once the components of a graph have been oriented, sorted, aligned,
and a direction has been chosen, it remains to determine the distance
between adjacent components. Two methods are available for computing
this distance, as specified by the following option:

\begin{key}{/graph drawing/component packing=\meta{method} (initially
    skyline)}
  \keyalias{tikz}
  \keyalias{tikz/graphs}
  Given two components, their distance is computed as follows in
  depencende of \meta{method}:
  \begin{itemize}
  \item \declare{|rectangular|}

    Imagine a bounding box to be drawn around both components. They
    are then shifted such that the padding (separating distance)
    between the two boxes is the current value of |component sep|.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw}, component sep=0pt,
              component packing=rectangular]
  { a -- long text, longer text -- b};
\end{codeexample}
  \item \declare{|skyline|}

    The ``skyline method'' described in the introduction of 
    Section~\ref{subsection-library-graphdrawing-anchoring} is used to
    compute the distance.
\begin{codeexample}[]
\tikz \graph [tree layout, nodes={draw}, component sep=0pt,
              component packing=skyline]
  { a -- long text, longer text -- b};
\end{codeexample}
  \end{itemize}
\end{key}



\subsection{Implementing Graph Drawing Algorithms}

\label{section-gd-own-algorithm}
\label{section-library-graphdrawing-ownAlgorithm}

This section presents a simple example of how a graph drawing
algorithm can be implemented. A more detailed explanation of how
new graph drawing algorithms can be integrated and configured in given
in Section~\ref{section-gd-implementing-algorithms}.

As explained for the |algorithm| key, for each graph drawing algorithm
there must be a class of the name given to the |algorithm| key. This
class should usually reside in a file called
|pgfgd-algorithm-|\meta{algorithm name}. This class must provide (at
least) the two methods |new| and |run|. Each time a layout needs to
be computed for a graph, a new object of this algorithm class is
instantiated using the class's |new| method. For the newly created
object, an attribute |graph| will be set to an object representing the
graph. Then, the |constructor| method of the object is called,
provided it exists. Then, the |run| method is called, which should do
the actual work. (The separation into a constructor and a run method
is purely for convenience.) The |run| method should modify the
coordinates of the nodes of its |graph| attribute.

To simplify the creating of classes and constructors, the graph
drawing engine provides the function |graph_drawing_algorithm|, which
takes a table of infos about the algorithm as input and will create a
class and a constructor.

As a complete example, the following code fragment implements a
trivial graph drawing algorithm that just places all nodes on a
fixed-size circle.  It is accessed with the name 
|Simple Demo|.

\pgfgddeclareforwardedkeys{/graph drawing}{
  radius/.graph parameter=evaluate math expression,
  radius/.parameter initial=1cm,
  node radius/.node parameter=evaluate math expression
}

\begin{codeexample}[code only]
-- File pgfgd-algorithm-SimpleDemo.lua

graph_drawing_algorithm { name = "SimpleDemo" }

function SimpleDemo:run()
  local radius = 28.908  -- this is 1cm in points
  local alpha = (2 * math.pi) / #self.graph.nodes
  for i=1,#self.graph.nodes do
    self.graph.nodes[i].pos.x = radius * math.cos((i-1) * alpha)
    self.graph.nodes[i].pos.y = radius * math.sin((i-1) * alpha)
  end
end
\end{codeexample}

The algorithm computes a circular layout like in the following.

\begin{codeexample}[]
\tikz [graph drawing scope, /graph drawing/algorithm=Simple Demo]
  \graph { f -> c -> e -> a -> {b -> {c, d, f}, e -> b}};
\end{codeexample}

For details on how to make things like |radius| configurable and how
to setup keys so that users can just write
|\tikz[circular layout] ...|, please see Section~\ref{section-gd-implementing-algorithms}.


\endinput

