% Copyright 2011 by RenÃ©e Ahrens, Olof Frahm, Jens Kluttig, Matthias Schulz, Stephan Schuster
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Graph Drawing Layouts: Trees}
\label{section-first-graphdrawing-library-in-manual}
\label{section-library-graphdrawing-trees}

{\noindent {\emph{by Till Tantau}}

\begin{tikzlibrary}{graphdrawing.trees}
  Load this package when you wish to use layout trees. You should load
  the |graphdrawing| library first. 
\end{tikzlibrary}


\tikzname\ offers several different syntax to specify trees (see
Sections \ref{section-library-graphs} and~\ref{section-trees}). By
default, \tikzname\ will attempt to produce a reasonable layout of the
specified trees, but since \TeX's algorithmic capabilities are quite
limited, no advanced layout of the tree is done by the standard
algorithms. This is where the graph drawing algorithms from this
library come in: Having the full power of Lua\TeX\ at their disposal,
they will produce a far better layout of the trees.



\subsection{Spanning Tree Computation}

Although the algorithms of this library are tailored to layout trees,
they will work for any graph as input. First, if the graph is not
connected, it is decomposed into connected components and these are
layed out individiually. Second, for each component, a spanning tree of
the graph is computed first and the layout is computed for this
spanning tree, all other edges will still be drawn, but they have no
impact on the placement of the nodes. If the graph is already a tree,
the spanning tree will be the original graph.

The computation of the spanning tree is a non-trivial process since
a non-tree graph has many different possible spanning trees. For the
time being, the computation methods for deciding on a spanning tree
are hardcoded into the graph drawing engine, but this may change in
the future, allowing you to choose and implement new spanning tree
computation algorithms dynamically.  You can
influence the spanning tree computation with the following keys:

\begin{key}{/graph drawing/spanning tree method=\meta{method}}
  \keyalias{tikz}\keyalias{tikz/graphs}
  The computation of the spanning tree proceeds as follows for each component:
  \begin{enumerate}
  \item We look for a node for which the following graph parameter is
    set:
    \begin{key}{/graph drawing/root}
      \keyalias{tikz}\keyalias{tikz/graphs}
    \end{key}
    If there are several such nodes, the first one is used. If there
    are no such nodes, the first node of indegree 0 (with respect to
    |->| edges) is used. If there is no such node, the first node is
    used. 
  \end{enumerate}
\end{key}




\subsection{The Reingold--Tilford Tree Layout}

\begin{gdalgorithm}{tree layout}{Tree Reingold Tilford 1981}
  This layout arranges nodes in a tree according to the
  Reingold--Tilford method.
\begin{codeexample}[]
\tikz [binary tree layout, sibling distance=7mm, level distance=10mm]
\graph [nodes={circle, inner sep=0pt, minimum size=2mm, fill}]{
  / -- { / -- / -- { / -- /, / -- { /, / }}, / -- / -- /[second] }
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, level distance=10mm] {
  Knuth -> {
    Beeton -> Kellermann [second] -> Carnes,
    Tobin -> Plass -> { Lamport, Spivak } 
  }
};\qquad
\tikz \graph [binary tree layout, grow'=right, sibling distance=5mm] {
  Knuth -> {
    Beeton -> Kellermann [second] -> Carnes,
    Tobin -> Plass -> { Lamport, Spivak } 
  }
};
\end{codeexample}
\begin{codeexample}[]
\tikz \graph [binary tree layout, grow'=30, sibling distance=5mm] {
  Knuth -> {
    Beeton -> Kellermann [second] -> Carnes,
    Tobin -> Plass -> { Lamport, Spivak } 
  }
};
\end{codeexample}
\end{gdalgorithm}

% \begin{gdalgorithm}{centered root tree layout}{A proof-of-concept by Ahrens et al., 2011}{AhrensFKSS2011 tree}
%   This algorithm was implemented as a proof-of-concept by Ahrens,
%   Frahm, Kluttig, Schulz, and Schuster, who have implemented the graph
%   drawing engine. The idea is that the 
%   root of each subtree is centered horizontally above the child
%   trees. The |sibling distance| and |level distance| keys are taken
%   into consideration.
  
% \begin{codeexample}[]
% \tikz[centered root tree layout, nodes=draw] \graph { a -> {b -> {c,d,f->{i,j,k}}, e}};
% \end{codeexample}

% As you can see, the text nodes aren't quite aligned, so the common fix
%   is to use the |text depth| and |text height| keys to force the text
%   nodes to a specific size.

% \begin{codeexample}[]
% \tikz[AhrensFKSS2011 tree, text depth=.2em, text height=.8em]
%   \graph { a -> {b -> {c,d}, e}};
% \end{codeexample}

%   \medskip
%   \noindent\textbf{Parameters.} 
%   The keys affecting the algorithm are the following common graph
%   drawing parameters:

%   \begin{key}{/graph drawing/root}
%     \keyalias{tikz}\keyalias{tikz/graphs}
%     This is a node parameter. At most one node should have this key
%     set. If no node has it set, the first node in the graph will be
%     used. 
%   \end{key}

%   \begin{key}{/graph drawing/level distance=\meta{leveldistance} (default 1cm)}
%     \keyalias{tikz}\keyalias{tikz/graphs}
%     Determines the vertical space between the nodes on different levels:
% \begin{codeexample}[]
% \tikz [AhrensFKSS2011 tree, level distance=1cm]
%   \graph { 1 -> {2 , 3}};
% \tikz [AhrensFKSS2011 tree, level distance=2cm]
%   \graph { 1 -> {2 , 3}};
% \end{codeexample}
%   \end{key}

%   \begin{key}{/graph drawing/sibling distance=\meta{siblingdistance} (default 1cm)}
%     \keyalias{tikz}\keyalias{tikz/graphs}
%     This determines the horizontal space between the nodes. 
% \begin{codeexample}[]
% \tikz [AhrensFKSS2011 tree, sibling distance=1cm]
%   \graph { 1 ->{2 , 3}};
% \tikz [AhrensFKSS2011 tree, sibling distance=2cm]
%   \graph { 1 ->{2 , 3}};
% \end{codeexample}
% \end{key}

%   \medskip
%   \textbf{How does this algorithm work?}
%   The tree algorithm works recursively. During the recursion one step is
%   performed for each subgraph of the tree.  

%   The process builds a kind of a box structure of the given graph. This
%   means a leaf of a tree returns itself as a box. Its parent returns
%   itself and its children in a bigger box etc. as shown in the following
%   figure. 

% \begin{quote}
% \begin{tikzpicture}[
%     level 0/.style={draw=black!50,very thick},
%     level 1/.style={draw=orange!50,very thick},
%     level 2/.style={draw=blue!50,very thick},
%     level 3/.style={draw=green!50,very thick}]

%     \node[level 1] (1) {1}
%       child {node[level 2] (3) {3}
%         child {node[level 3] (4) {4}
%           child{node[level 3] (6) {6}}
%           child{node[level 3] (7) {7}}
%         }
%         child {node[level 2] (5) {5}}
%       }
%       child {node[level 1] (2) {2}};

%     \begin{pgfonlayer}{background}
%         \node [level 0, fit=(1) (6) (2)] {};
%         \node [level 1, fit=(3) (5) (6) (7)] {};
%         \node [level 2,fit=(4) (6) (7)] {};
%     \end{pgfonlayer}
% \end{tikzpicture}
% \end{quote}

%   In each step the current boxes can be compared by their size, sorted
%   and positioned. In the figure above the boxes of one step are
%   represented in the same color. 
  
%   In the tree algorithm the boxes of each tree level are first sorted
%   ascendingly by their size and then arranged as follows: The the
%   biggest box is positioned in the middle. Then the following boxes are
%   positioned alternately left and right. 
  
%   After this arrangement the relative coordinates for the position of
%   each box have to be computed. The \emph{y}-coordinate of a box (except
%   for the root node of the step) are determined by the maximum height of
%   all boxes to guarantee a uniform layout of the tree. Nodes on the same
%   level in the tree are positioned at the same height. The
%   \emph{x}-coordinate of a box depends on the coordinates of its left
%   neighbour box and an additional spacing (by default 10pt), which can
%   be influenced by the |sibling distance| key. The \emph{y}-coordinate
%   of the root node of each step is set to the maximum \emph{y}-value of
%   the other boxes adding the same spacing meantioned above (by default
%   10pt, influenced by |level distance|). Its \emph{x}-coordinate is
%   determined by the width of the other boxes divided by 2. This means
%   the root node is positioned in the middle above the other boxes. 
  
%   Because each box knows its root node, it is possible to determine the
%   absolute position of each box or node afterwards.  
  
%   At the end of the step the current boxes are added to a result box and
%   returned. 
%\end{gdalgorithm}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual-pdftex-version"
%%% End: 
