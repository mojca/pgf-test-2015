% Copyright 2010 by Ren√©e Ahrens, Olof Frahm, Jens Kluttig, Matthias Schulz, Stephan Schuster
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS[v\pgfversion] $Header: /cvsroot/pgf/pgf/generic/pgf/graphdrawing/tex/pgflibrarygraphdrawing.code.tex,v 1.23 2012/11/20 23:34:18 tantau Exp $



% check if luatex is running

\ifx\directlua\relax%
  \PackageError{pgf}{You need to run LuaTeX to use the graph drawing library}{}
  \expandafter\endinput
\fi
\ifx\directlua\undefined%
  \PackageError{pgf}{You need to run LuaTeX to use the graph drawing library}{}
  \expandafter\endinput
\fi




% 
% All graph drawing keys normally live in the following namespace:
% /graph drawing. 
%

\def\pgfgdset{\pgfqkeys{/graph drawing}}


% Setup a key
% 
% #1 = key
% 
% Description:
% 
% An internal macro that sets up #1 as a graph drawing key.

\def\pgfgd@callbackkey#1{
  \pgf@gd@setup@forwards{#1}
  \pgfutil@g@addto@macro\pgf@gd@forwards@list{\pgf@gd@setup@forwards{#1}}
}
\def\pgf@gd@setup@forwards#1{
  \let\pgf@temp\pgfutil@empty
  \foreach \pgf@gd@path in \pgf@gd@forwarding@list {
    \ifx\pgf@gd@path\pgfutil@empty\else%
      \expandafter\pgfutil@g@addto@macro%
      \expandafter\pgf@temp\expandafter{%
        \expandafter\pgfkeys\expandafter{\pgf@gd@path#1/.forward to=/graph drawing/#1}}
    \fi%
  }%
  \pgf@temp
}

\let\pgf@gd@forwards@list\pgfutil@empty


% Append to the forwarding list:
% 
% #1 = paths to append to the forwarding list
% 
% Description:
% 
% Append the paths in #1 (with trailing slashes) to the forwarding
% list.
% 
% If algorithms have already been declared, forwarding will also be
% setup for them (using a bit of magic...).

\def\pgfgdappendtoforwardinglist#1{%
  \let\pgf@gd@forwarding@list@orig\pgf@gd@forwarding@list
  \def\pgf@gd@forwarding@list{#1}%
  \pgf@gd@forwards@list%
  \expandafter\def\expandafter\pgf@gd@forwarding@list\expandafter{\pgf@gd@forwarding@list@orig,#1}
}
\let\pgf@gd@forwarding@list\pgfutil@empty



% 
% 
% Callbacks
% 
% The following macros are called *from* the binding layer. You do not
% call them from the pgf layer.
%  
%


% Callback for declaring a graph parameter key
%
% #1 = Parameter key
% #2 = Parameter type
% #3 = Parameter default value
%
% Description:
%
% When a graph drawing algorithm starts working, a set of options,
% called "graph drawing parameters" in the following, can influence the
% way the algorithm works. For instance, an graph drawing parameter
% might be the average distance between vertices which the algorithm
% should take into account. Another example might be the fact the
% certain nodes are special nodes and that a certain edge should have
% a large label.
%
% These graph drawing parameters are different from "usual" pgf
% options: An alogrithmic parameter influenced the way the algorithm
% works, while usual options normally only influence how the result
% looks like. For instance, the fact that a node is red is not an
% graph drawing parameter (usually, at least), while the shape of a node
% might be an graph drawing parameter.
%
% Graph drawing parameters are declared by the algorithmic layer
% (since only this layer "knows" which parameters there are). The
% binding to TeX will call the \pgfgddeclareparameter function
% internally.
% 
% Specifying the set of graph drawing parameters for a given graph or
% node or edge works as follows: When the graph drawing engine is
% started for a graph (using \pgfgdbeginscope), a snapshot is taken of
% all graph drawing parameters currently setup at this
% point. Similarly, when a node is created inside such a scope, a
% snapshot is taken of the set of all graph drawing parameters in
% force at this point is taken and stored together with the
% node. Finally, when an edge is created, a snapshot of the setting of
% the graph drawing parameters is taken.

\def\pgfgdcallbackdeclareparameter#1#2#3{%
  \pgfkeysdef{/graph drawing/#1}{\pgf@gd@handle@parameter{#1}{#2}{##1}}%
  \def\pgf@temp{#3}%
  \ifx\pgf@temp\pgfutil@empty\else%
    \pgfkeys{/graph drawing/#1/.default={#3}}
  \fi%
  \pgfgd@callbackkey{#1}%  
}
\def\pgf@gd@handle@parameter#1#2#3{%
  \pgfkeys{/graph drawing/conversions/#2={#3}}%
  \advance\pgf@gd@parameter@stack@height by1\relax%
  \directlua{pgf.gd.interface.InterfaceToDisplay.pushOption%
    ('\luaescapestring{#1}',\pgfgdresult,\the\pgf@gd@parameter@stack@height)}
}%
\newcount\pgf@gd@parameter@stack@height

\def\pgfgdcallbacksetinitial#1#2#3{%
  \pgfkeys{/graph drawing/conversions/#2={#3}}%
  \directlua{pgf.gd.interface.InterfaceToDisplay.setOptionInitial('\luaescapestring{#1}',\pgfgdresult)}
}

% Conversions are used to adapt the syntactic description of a
% parameter on the TikZ layer to the one expected by Lua. The set of
% permissible conversions is described in
% InterfaceToAlgorithms.declareParameter. 

\pgfgdset{
  conversions/string/.code=\def\pgfgdresult{'\luaescapestring{\detokenize{#1}}'},
  conversions/raw/.code=\def\pgfgdresult{#1},
  conversions/boolean/.code=\def\pgf@test{#1}\ifx\pgf@test\pgf@truetext\def\pgfgdresult{true}\else\ifx\pgf@test\pgfkeysnovalue@text\def\pgfgdresult{true}\else\def\pgfgdresult{false}\fi\fi,
  conversions/number/.code=\pgfmathparse{#1}\let\pgfgdresult\pgfmathresult,
  conversions/length/.code=\pgfmathparse{#1}\let\pgfgdresult\pgfmathresult,
  conversions/direction/.code=\pgf@lib@gd@grow@dir{#1}\let\pgfgdresult\pgfmathresult,
  conversions/canvas coordinate/.code args={(#1pt,#2pt)}{\edef\pgfgdresult{pgf.gd.model.Coordinate.new(#1,#2)}},
  % deprecated, will be removed:
  conversions/coordinate/.code args={(#1pt,#2pt)}{\edef\pgfgdresult{{#1,#2}}},
  conversions/number with optional and/.code={
    \pgfutil@in@{ and }{#1}%
    \ifpgfutil@in@%
      \pgf@gd@convert@and#1\pgf@stop%
    \else%
      \pgf@gd@convert@and#1 and #1\pgf@stop%
    \fi%
  },
  conversions/table with node keys/.code=\def\pgfgdresult{pgf.gd.control.TeXInterface.convertNameKeysToVertexKeys({#1})},
}
\def\pgf@truetext{true}

\def\pgf@gd@convert@and#1 and #2\pgf@stop{\pgfmathparse{#1}\let\pgfgdresult\pgfmathresult}

\def\pgf@lib@gd@grow@dir#1{%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\pgf@gd@lib@active@bar%
    \def\pgfmathresult{-90}
  \else%
    \ifcsname pgf@orient@direction@#1\endcsname%
      \expandafter\let\expandafter\pgfmathresult\csname pgf@orient@direction@#1\endcsname%
    \else
      \pgfmathparse{#1}%
    \fi
  \fi
}

\def\pgf@orient@direction@down{-90}
\def\pgf@orient@direction@up{90}
\def\pgf@orient@direction@left{180}
\def\pgf@orient@direction@right{0}

\def\pgf@orient@direction@south{-90}
\def\pgf@orient@direction@north{90}
\def\pgf@orient@direction@west{180}
\def\pgf@orient@direction@east{0}

\expandafter\def\csname pgf@orient@direction@north east\endcsname{45}
\expandafter\def\csname pgf@orient@direction@north west\endcsname{135}
\expandafter\def\csname pgf@orient@direction@south east\endcsname{-45}
\expandafter\def\csname pgf@orient@direction@south west\endcsname{-135}

\expandafter\def\csname pgf@orient@direction@-\endcsname{0}
\expandafter\def\csname pgf@orient@direction@|\endcsname{-90}

{
  \catcode`\|=13
  \gdef\pgf@gd@lib@active@bar{|}
}



% Callback for declaring a graph parameter style
%
% #1 = Style key
% #2 = List of to-be-executed keys.
% #3 = A default value
%
% Description:
% 
% This callback is called to declare a style.

\def\pgfgdcallbackdeclareparametersequence#1#2#3{%
  \pgfkeys{/graph drawing/#1/.style={#2}}%
  \def\pgf@temp{#3}%
  \ifx\pgf@temp\pgfutil@empty\else%
    \pgfkeys{/graph drawing/#1/.default={#3}}
  \fi%
  \pgfgd@callbackkey{#1}%  
}


% Callback for declaring a graph drawing algorithm
%
% #1 = Key
% #2 = Phase
%
% Description:
% 
% This callback is called to declare a key that selects a specific
% graph drawing algrorithm.

\def\pgfgdcallbackdeclarealgorithm#1#2{%
  \def\pgf@temp{#2}%
  \ifx\pgf@temp\pgf@gd@maintext%
    \pgfkeysdef{/graph drawing/#1}{\pgf@gd@handle@phase{#1}{#2}\pgfgdset{request scope and layout}}%
  \else
    \pgfkeysdef{/graph drawing/#1}{\pgf@gd@handle@phase{#1}{#2}}%
  \fi%
  \pgfgd@callbackkey{#1}%  
}
\def\pgf@gd@handle@phase#1#2{%
  \advance\pgf@gd@parameter@stack@height by1\relax%
  \directlua{pgf.gd.interface.InterfaceToDisplay.pushPhase%
    ('\luaescapestring{#1}','\luaescapestring{#2}',\the\pgf@gd@parameter@stack@height)}
}%
\def\pgf@gd@maintext{main}



% Callback for declaring a collection kind
%
% #1 = Key
%
% Description:
% 
% This callback is called to declare a key that creates a new
% collection kind. See |Binding.declare_collection_kind| for details.
%

\def\pgfgdcallbackdeclarecollectionkind#1{
  \pgfkeysdef{/graph drawing/#1}{\pgf@gd@make@collection{#1}}
  \pgfgd@callbackkey{#1}%  
}

\def\pgf@gd@make@collection#1{%
  \advance\pgf@gd@parameter@stack@height by1\relax%
  \directlua{pgf.gd.interface.InterfaceToDisplay.pushCollection%
    ('\luaescapestring{#1}',\the\pgf@gd@parameter@stack@height)}%
}



% Callback for starting the rendering of a collection kind
%
% #1 = Kind
% #2 = Layer
%
% Description:
% 
% Executes /graph drawing/#1/begin rendering/.try
%

\def\pgfgdcallbackrendercollectionkindstart#1#2{
  \ifnum#2<0\relax
    \setbox\pgf@gd@prekind@box=\hbox\bgroup%
    \unhbox\pgf@gd@prekind@box%
  \else%
    \setbox\pgf@gd@postkind@box=\hbox\bgroup%
    \unhbox\pgf@gd@postkind@box%
  \fi
  \pgfgdset{/graph drawing/#1/begin rendering/.try}
}


% Callback for ending the rendering of a collection kind
%
% #1 = Kind
% #2 = Layer
%
% Description:
% 
% Executes /graph drawing/#1/end rendering/.try
%

\def\pgfgdcallbackrendercollectionkindstop#1{
  \pgfgdset{/graph drawing/#1/end rendering/.try}
  \egroup % close box
}



% Callback for rendering a collection 
% 
% #1 = Kind
% #2 = Options
%
% Description:
% 
% Executes /graph drawing/#1/render/.try={#2}
%

\def\pgfgdcallbackrendercollection#1#2{
  \pgfgdset{/graph drawing/#1/render/.try={#2}}
}





% Graph events  
% 
% Although a graph consists of nodes and edges, during the
% construction of the graph a lot of information concerning the
% structure of the graph is often available. For instance, as we
% specify a graph using the child-syntax, we do not only which edges
% are present, but we can implicitly specify an ordering on the
% nodes. Even more, there is even information availble concerning
% nodes that are not present at all: A child[missing] is not present
% as a node or an edge, but a tree drawing algorithm will want to know
% about this child nevertheless.
% 
% In order to communicate such information to the graph drawing
% engine, "events" are used. As a graph is created, in addition to
% nodes and edges, "events" may happen. The events come in a
% sequential order and they are stored together with the graph. For
% each node and each edge, its index in the event sequence is
% stored, that is, it is stored how many events happened before the
% node or edge was created.
% 
% Internally, an event consists of a name and, possibly, some
% parameters. When the parameter is created on the tikz level, it will
% be a string that is passed down to Lua. Internally created events
% will also have parameters that are objects.
% 
% Two events are a bit special since they get special internal
% support: The begin and end events. The first signals that some kind
% of group has started; which is closed by the corresponding end
% event. The "kind" of group is indicated by the parameter of the
% begin event.
% 
% 
% 
% Standard events are:
% 
% For each node entered into a graph, a "node" event is automatically
% created internally with the parameter being the node. However, you
% can also create this event yourself. In this case, the parameter
% will be a string and will mean that the node is "virtual" or
% "missing", but space should be reserved for it, if possible (this is
% use, for instance, by certain tree layouts).
% 
% For each edge entered into a graph, an "edge" event is automatically
% created, with the edge as the parameter. Again, an event with a
% string parameter corresponds to a "non-existing" node.
% 
%
% Standard event groups are:
% 
%
% The "descendants" event group include a set of nodes that, at least
% inside the specification, are descendants of the last node
%
% begin descendants
% ...
% end
% 
% 
% The "array" event group collects together some nodes in an array of
% nodes. This can be used, for instance, to specify matrices.
% 
% begin array
% ...
% end 



% Create a new event
% 
% #1 = event name (should be a valid lua identifier name)
% #2 = parameter (some text)
% 
% Description:
% 
% Adds a new event to the event sequence of the graph

\def\pgfgdevent#1#2{%
  \directlua{pgf.gd.interface.InterfaceToDisplay.createEvent('\luaescapestring{#1}', '\luaescapestring{#2}')}%
}


% Start an event group
% 
% #1 = kind of event group
% 
% Description:
% 
% Creates a begin event with #1 as the parameter of the begin
% event.

\def\pgfgdbegineventgroup#1{%
  \pgfgdevent{begin}{#1}%
}

% End an event group
% 
% Description:
% 
% Creates an end event.

\def\pgfgdendeventgroup{%
  \pgfgdevent{end}{}%
}


% Creates an event group for the current TeX group
%
% #1 = event group name 
%
% Description:
% 
% Issues a begin event for #1 and, using \aftergroup, adds an end
% event at the end of the current tex group.

\def\pgfgdeventgroup#1{%
  \pgfgdbegineventgroup{#1}%
  \aftergroup\pgfgdendeventgroup%
}





%
% Nodes
%



%
% Callback method for \pgfpositionnodelater
% 
% This function is called by \pgfnode whenever a node has been newly
% created inside a graph drawing scope. It will create a new vertex on
% the Lua layer.
%
\def\pgf@gd@positionnode@callback{%
  {%
    % evaluate coordinates
    \pgfmathsetmacro{\pgf@gd@node@minx}{\pgfpositionnodelaterminx}%
    \pgfmathsetmacro{\pgf@gd@node@miny}{\pgfpositionnodelaterminy}%
    \pgfmathsetmacro{\pgf@gd@node@maxx}{\pgfpositionnodelatermaxx}%
    \pgfmathsetmacro{\pgf@gd@node@maxy}{\pgfpositionnodelatermaxy}%
    % call lua system library to create a lua node object
    \directlua{
      local new = pgf.gd.model.Coordinate.new
      pgf.gd.interface.InterfaceToDisplay.createVertex(
        string.sub('\luaescapestring{\pgfpositionnodelatername}',30), % strip "not yet positionedPGFINTERNAL"
        '\luaescapestring{\csname pgf@sh@ns@\pgfpositionnodelatername\endcsname}',
        {
          new(\pgf@gd@node@minx, \pgf@gd@node@miny),
          new(\pgf@gd@node@minx, \pgf@gd@node@maxy),
          new(\pgf@gd@node@maxx, \pgf@gd@node@maxy),
          new(\pgf@gd@node@maxx, \pgf@gd@node@miny),
        },
        \the\pgf@gd@parameter@stack@height,
        {
          x_min = \pgf@gd@node@minx,
          y_min = \pgf@gd@node@miny,
          x_max = \pgf@gd@node@maxx,
          y_max = \pgf@gd@node@maxy,
        }
      )
    }
  }%
}

% Set options for an already existing node
% 
% #1 = node name
% 
% These node parameters of #1 will be updated with the current values
% of the node parameters. The node #1 must previously have been passed
% to the gd engine. If some of the options have already been set for
% the node, these settings will be overruled.

\def\pgfgdsetlatenodeoption#1{%
  \directlua{
    pgf.gd.interface.InterfaceToDisplay.addToVertexOptions('\luaescapestring{#1}',\the\pgf@gd@parameter@stack@height)
  }
}



%
% A callback for rendering (finally positioning) a node
% 
% #1 = name of the node
% #2 = x min of the bounding box
% #3 = x max of the bounding box
% #4 = y min of the bounding box
% #5 = y max of the bounding box
% #6 = desired x pos of the node
% #7 = desired y pos of the node
% #8 = box register number of the TeX node
%
% This callback will be called by the engine for every original node
% when it finally needs to placed at a final position.

\def\pgfgdcallbackrendernode#1#2#3#4#5#6#7#8{%
  {%
    \def\pgfpositionnodelatername{#1}
    \def\pgfpositionnodelaterminx{#2}
    \def\pgfpositionnodelatermaxx{#3}
    \def\pgfpositionnodelaterminy{#4}
    \def\pgfpositionnodelatermaxy{#5}
    \directlua{pgf.gd.interface.InterfaceCore.binding:retrieveBox(#8,\pgfpositionnodelaterbox)}
    \pgfpositionnodenow{\pgfqpoint{#6pt}{#7pt}}
  }%
}



% Adds an edge to the graph
%
% #1 = first node
% #2 = second node
% #3 = edge direction
% #4 = edge options (will be executed in a protected environment)
% #5 = aux stuff (curtesy for TikZ -- edge nodes)
%
% Description:
%
% Creating an edge means that you tell the graph drawing algorithm
% that #1 and #2 are connected. The "kind" of connection is indicated
% by #3, which may be one of the following:
% 
% ->  = a directed edge (also known as an arc) from #1 to #2
% --  = an undirected edge between #1 and #2
% <-  = a directed edge from #2 to #1, but with the "additional hint"
%       that this is a "backward" edge. A graph drawing algorithm may
%       or may not take this hint into account
% <-> = a bi-directed edge between #1 and #2.
% 
%
% The parameters #4 and #5 are a bit more tricky. When an edge between
% two vertices of a graph is created via \pgfgdedge, nothing is
% actually done immediately. After all, without knowing the final
% positions of the nodes #1 and #2, there is no way of
% creating the actual drawing commands for the edge. Thus, the actual
% drawing of the edge is done only when the graph drawing algorithm is
% done (namely in the macro \pgfgdcallbackedge, see later).
% 
% Because of this "delayed" drawing of edges, options that influence
% the edge must be retained until the moment when the edge is actually
% drawn. Parameters #4 and #5 store such options.
% 
% Let us start with #4. This parameter should be set to a list of
% key-value pairs like
% 
%   /tikz/.cd, color=red, very thick, this edge must be vertical
% 
% Some of these options may be of interest to the graph drawing
% algorithm (like the last option) while others will 
% only be important during the drawing of edge (like the first
% option). The options that are important for the graph drawing
% algorithm must be passed to the algorithm via setting keys that have
% been declared using the handler .edge parameter (see 
% above).
% 
% The tricky part is that options that are of interest to the graph
% drawing algorithm must be executed *before* the algorithm starts,
% but the options as a whole are usually only executed during the
% drawing of the edges, which is *after* the algorithm has finished.
% 
% To overcome this problem, the following happens:
% 
% The options in #4 are executed "tentatively" inside
% \pgfgdedge. However, this execution is done in a "heavily guarded
% sandbox" where all effects of the options (like changing the
% color or the line width) do not propagate beyond the sandbox. Only
% the changes of the graph drawing edge parameters leave the
% sandbox. These parameters are then passed down to the graph drawing
% engine.
% 
% Later, when the edge is drawn using \pgfgdcallbackedge, the options #4
% are available once more and then they are executed normally.
%
% Note that when the options in #4 are executed, no path is
% preset. Thus, you typically need to start it with, say, /tikz/.cd.
%
%
% The text in #5 is some "auxilliary" text that is simply stored away
% and later directly to \pgfgdcallbackedge. This is a curtesy to TikZ,
% which can use it to store its node labels. 
%
% Example:
%
% \pgfgdedge{A}{B}{->}{red}{}
%
\def\pgfgdedge#1#2#3#4#5{%
  % Ok, setup sandbox
  \begingroup%
    \setbox0=\hbox{{%
        \pgfinterruptpath%
          \pgfgdprepareedge%
          \pgfkeys{#4}%
          % create edge in Lua
          \toks0={#4}%
          \toks1={#5}%
          \directlua{
            pgf.gd.interface.InterfaceToDisplay.createEdge(
            '\luaescapestring{#1}','\luaescapestring{#2}','\luaescapestring{#3}',
            \the\pgf@gd@parameter@stack@height,
            { pgf_options = '\luaescapestring{\the\toks0}',
              pgf_edge_nodes = '\luaescapestring{\the\toks1}',
            })
          }%
        \endpgfinterruptpath%
      }}%
  \endgroup%
}

\let\pgfgdprepareedge=\pgfutil@empty
\def\pgfgdaddprepareedgehook#1{\expandafter\def\expandafter\pgfgdprepareedge\expandafter{\pgfgdprepareedge#1}}


\newif\ifpgf@gd@nodes@behind@edges



% Define a callback for rendering edges
%
% #1 = macro name
% 
% Descriptions:
% 
% This is a callback from the graph drawing engine. At the end of the
% creation of a graph, when the nodes have been positioned, this macro
% is called once for each edge. The macro should take the following
% parameters:
% 
% #1 = from node, optionally followed by "." and the tail anchor
% #2 = to node, optionally followed by "." and the head anchor
% #3 = direction (<-, --, ->, or <->)
% #4 = original options
% #5 = aux text (typically edge nodes)
% #6 = algorithm-generated options
% #7 = bend information
%
% The first five parameters are the original values that were passed
% down to the \pgfgdedge command.
% 
% #6 contains options that have been "computed by the algorithm". For
% instance, an algorithm might have determined, say, flow capacities
% for edges and it might now wish to communicate this information back
% to the upper layers. These options should be executed with the path
% /graph drawing.
% 
% #7 contains algorithmically-computed information concerning how the
% edge should bend. This will be a text like
% "--(10pt,20pt)--(30pt,40pt)" in tikz-syntax, using the path
% operations "--", "..controls" and "--cycle".
% 
% By default, a simple line is drawn between the nodes. Usually, you
% will wish to install a more "fancy" callback, here.

\def\pgfgdsetedgecallback#1{\let\pgfgdcallbackedge=#1}

\def\pgfgddefaultedgecallback#1#2#3#4#5#6#7{%
  {%
    \pgfscope
      \pgfpathmoveto{
        \pgfutil@in@.{#1}%
        \ifpgfutil@in@
          \pgf@gd@unravel#1\relax%
        \else
          \pgfpointshapeborder{#1}{\pgfpointanchor{#2}{center}}
        \fi
      }
      \pgfpathlineto{
        \pgfutil@in@.{#2}%
        \ifpgfutil@in@
          \pgf@gd@unravel#2\relax%
        \else
          \pgfpointshapeborder{#2}{\pgfpointanchor{#1}{center}}
        \fi
      }
      \pgfusepath{stroke}
    \endpgfscope
  }
}

\pgfgdsetedgecallback{\pgfgddefaultedgecallback}

\def\pgf@gd@unravel#1.#2\relax{%
  \pgfpointanchor{#1}{#2}%
}




% Callbacks: Called before the shipout of nodes and edges starts
%
% First, the general begin shipout is called. Then, the node shipout
% starts, the nodes are created, and then the end of the node shipout
% is signaled. Next, the edge shipout starts and ends. Finally, the
% end shipout is called.

\def\pgfgdcallbackbeginshipout{%
  \pgfscope%
    \catcode`\@=11\relax%
    \setbox\pgf@gd@prekind@box=\box\pgfutil@voidb@x%
    \setbox\pgf@gd@postkind@box=\box\pgfutil@voidb@x%
}
\def\pgfgdcallbackendshipout{%
    \box\pgf@gd@prekind@box%
    \ifpgf@gd@nodes@behind@edges%
      \box\pgf@gd@node@box%
      \box\pgf@gd@edge@box%
    \else%
      \box\pgf@gd@edge@box%
      \box\pgf@gd@node@box%
    \fi%
    \box\pgf@gd@postkind@box%
  \endpgfscope
}

\newbox\pgf@gd@node@box
\newbox\pgf@gd@edge@box
\newbox\pgf@gd@prekind@box
\newbox\pgf@gd@postkind@box

\def\pgfgdcallbackbeginnodeshipout{%
  \setbox\pgf@gd@node@box=\hbox\bgroup%
}
\def\pgfgdcallbackendnodeshipout{%
  \egroup%
}

\def\pgfgdcallbackbeginedgeshipout{%
  \setbox\pgf@gd@edge@box=\hbox\bgroup%
}

\def\pgfgdcallbackendedgeshipout{%
  \egroup
}




% Generate a node 
%
% This callback is called from the engine whenever an algorithm
% generates a new node internally.
%
% #1 = name of the node
% #2 = shape of the node
% #3 = options generated by the algorithm in key-value syntax. The set
% of generated options is algorithm-dependent.
% #4 = text
%
% This is an internal function and will be called by the binding layer

\def\pgfgdcallbackcreatevertex#1#2#3#4{%
  {
    \pgfkeys{#3}
    \pgfnode{#2}{\pgfkeysvalueof{/graph drawing/generated
        node/anchor}}{#4}{#1}{\pgfkeysvalueof{/graph drawing/generated
        node/use path}} 
  }
}

\pgfkeys{
  /graph drawing/generated node/anchor/.initial=center,
  /graph drawing/generated node/use path/.initial=\pgfusepath{}
}



%
% Sublayouts
%
% Description: For a general introduction to (sub)layouts, see
% Section~\ref{section-gd-sublayouts} in the manual. 
% 

\def\pgfgdbeginlayout{
  \begingroup
    \pgfgdlayoutscopeactivetrue
    \advance\pgf@gd@parameter@stack@height by1\relax%
    \directlua{pgf.gd.interface.InterfaceToDisplay.pushLayout(\the\pgf@gd@parameter@stack@height)}
}

\def\pgfgdendlayout{
  \endgroup%
}

\def\pgfbegininterruptlayout{
  \begingroup%
    \pgfgdlayoutscopeactivefalse%
}

\def\pgfendinterruptlayout{
  \endgroup%
}




% Creates a subgraph node
% 
% #1 = name
% #2 = node options
% #3 = node text
% 
% Description:
% 
% A subgraph node is a node that "surrounds" the nodes of a
% subgraph. The special property of a subgraph node opposed to a
% normal node is that it is created only after the subgraph has been
% laid out. However, the difference to a collection like "hyper" is
% that the node is availble immediately as a normal node in the sense
% that you can connect edges to it.
% 
% What happens internally is that subgraph nodes get "registered"
% immediately both on the pgf level and on the lua level, but the
% actual node is only created inside the layout pipeline using a
% callback. The actual node creation happens when the innermost layout
% in which the subgraph node is declared has finished.
% 
% When you create a subgraph node using this macro, you also start a
% collection (of an internal kind) that stores the subgraph. All
% following nodes in the current TeX scope will become part of this
% collection. 
% 
% See |InterfaceToDisplay.pushSubgraphVertex| for details.

\def\pgfgdsubgraphnode#1#2#3{%
  \advance\pgf@gd@parameter@stack@height by1\relax%
  {%
    % create edge in Lua
    \toks0={#2}%
    \toks1={#3}%
    \directlua{pgf.gd.interface.InterfaceToDisplay.pushSubgraphVertex%
      ('\luaescapestring{#1}',\the\pgf@gd@parameter@stack@height,
      {
        shape = 'rectangle', % typically overwritten by the pgf_options:
        pgf_options = '\luaescapestring{\the\toks0}',
        text = '\luaescapestring{\the\toks1}',
      })
    }%
  }
}

\def\pgfgdsubgraphnodecontents#1{% helper function
  \hbox to \pgfkeysvalueof{/graph drawing/subgraph bounding box width}{%
    \vrule width0pt height\pgfkeysvalueof{/graph drawing/subgraph bounding box height}\hfil}%
}

\pgfgdset{
  subgraph point cloud/.initial=,
  subgraph bounding box width/.initial=,
  subgraph bounding box height/.initial=,
}


% 
% Requests
% 
% Description:
% 
% This key is used to ``request'' a graph drawing scope and a
% layout. The objective of this key is to make it easier for users and
% algorithm designers to control the slightly involved
% back-and-forth-calling between the different layers.
% 
% This key does the following: When called inside a pgfpicture
% (otherwise, the call is "illegal"), it will call a call-back with
% two parameters. This callback will get passed some code that should
% be executed at the beginning of ``the next scope'' and some code
% that should be executed at the end of that scope.
% 
% The code passed to the callbacks will have a different effect,
% depending on whether we are currently inside a layout scope or not
% (if no graph drawing scope is open, we are 
% not inside a layout). If we are not inside a layout scope (or if the
% layout scope has been interrupted), the code will issue a
% \pgfgdbeginscope command in the opening code and a corresponding
% scope ending command in the closing code. Next, the two code pieces
% always contain \pgfgdbeginlayout and \pgfgdendlayout.
% 
%
% The main use of this key is at the end of a layout style. The idea
% is that a typical style like, say, "tree layout" can be defined like
% this:
% 
% binary tree layout/.style={
%   algorithm=pgf.gd.trees.ReingoldTilford1981,
%   minimum number of children=2,
%   significant sep=1em,
%   request scope and layout
% }
%
% Note that the "request scope and layout" key will not immediately
% trigger a layout scope to be created; rather, the TikZ callback will
% call it only at the beginning of the scope, which will be after
% other options in the current list of options have been parsed. So,
% when you write \graph [binary tree layout, significant sep=2em] ...,
% the "significant sep" option has an effect despite being given
% *after* the "request scope and layout" key since the actual opening
% of the scope happens only before the "..." part is parsed.

\pgfgdset{request scope and layout/.code=\pgfgd@requestcallback{\pgfgdbeginrequest}{\pgfgdendrequest}}

\def\pgfgd@requestcallback#1#2{%
  #1\def\pgf@gd@after@request{#2\egroup}\bgroup\aftergroup\pgf@gd@after@request%
} % Default for basic layer

\def\pgfgdbeginrequest{%
  \ifpgfgdlayoutscopeactive%
  \else%
    \expandafter\pgfgdbeginscope%
  \fi%
      \pgfgdbeginlayout%  
}
\def\pgfgdendrequest{%
      \pgfgdendlayout%
  \ifpgfgdlayoutscopeactive%
  \else%
    \expandafter\pgfgdendscope%
  \fi%  
}
\newif\ifpgfgdlayoutscopeactive


% Set the request callback
% 
% #1 = A macro
% 
% Description:
% 
% Sets the request callback as described in the "request scope and
% layout" key.

\def\pgfgdsetrequestcallback#1{\let\pgfgd@requestcallback#1}




%
% An if that is true exactly if we are inside a graph drawing scope
%

\newif\ifpgfgdgraphdrawingscopeactive


% Begins a new graph drawing scope
% 
% Description:
%
% Inside a graph drawing scope, all pgf nodes that are newly created
% are automatically passed to the graph drawing engine. In contrast,
% edges have to be indicated explicitly using the macro \pgfgdedge
% (this is because it is somewhat unclear what, exactly, should count
% as an edge). Naturally, users typically will not call \pgfgdedge
% explicitly, but have styles and keys invoke it internally.
%
% Usage:
% 
% \pgfgdset{algorithm=somealgorithm}
% \pgfgdbeginscope
%   \pgfnode{rectangle}{center}{A}{A}{}
%   \pgfnode{rectangle}{center}{B}{B}{}
%   \pgfnode{rectangle}{center}{C}{C}{}
%   \pgfgdedge{A}{B}{->}{}{}
%   \pgfgdedge{B}{C}{->}{}{}
%   \pgfgdedge{C}{A}{->}{}{}
% \pgfgdendscope
% 
% Naturally, users will typically use TikZ's somewhat simpler syntax: 
% 
% \tikz \graph [some algorithm] { A -> B -> C -> A };

\def\pgfgdbeginscope{%
  \begingroup % Protecting scope
    % get options
    \directlua{
      pgf.gd.interface.InterfaceToDisplay.beginGraphDrawingScope(\the\pgf@gd@parameter@stack@height)
    }%
    \begingroup % Inner scope, the actual nodes will be inserted after
                % this scope has been closed
      % Indicate that we are now inside a graph drawing scope
      \pgfgdgraphdrawingscopeactivetrue
      % Switch on late positioning
      \pgfpositionnodelater{\pgf@gd@positionnode@callback}
      % Switch on late edges
      \pgfgd@latecallback%
      % Kill transformations (will be added by the position now
      % macros)
      \pgftransformreset
}


% Ends a graph drawing scope
% 
% Description:
%
% This macro invokes the selected graph drawing algorithm and
% ships out all nodes within this scope
%
% See \pgfgdbeginscope

\def\pgfgdendscope{%
      \directlua{
        pgf.gd.interface.InterfaceToDisplay.runGraphDrawingAlgorithm()
      }
    \endgroup
    % Late positioning has ended
    \directlua{pgf.gd.interface.InterfaceToDisplay.renderGraph()}
    \directlua{pgf.gd.interface.InterfaceToDisplay.endGraphDrawingScope()}
  \endgroup
}







% Hook into graph specification
% 
% #1 = code
% 
% Description:
% 
% Allows you to specify code that should be active while the graph
% drawing engine collects the information concerning the graph, but
% which should no longer be active when the graph is rendered.

\def\pgfgdaddspecificationhook#1{
  \expandafter\def\expandafter\pgfgd@latecallback\expandafter{\pgfgd@latecallback#1}
}
\let\pgfgd@latecallback\pgfutil@empty










% Loading further libraries

% Include a graph drawing library file.
%
% #1 = List of names of library file.
%  
% Description:
%
% This command includes a list of graph drawing library files. For
% each file X in the list, the file pgf.gd.X.lua is included using
% |require|. 
%
% For the convenience of Context users, both round and square brackets
% are possible for the argument.
% 
%
% Example:
%
% \usegdlibrary{trees}
% \usegdlibrary[force,circular]

\def\usegdlibrary{\pgfutil@ifnextchar[{\use@gdlibrary}{\use@@gdlibrary}}%}
\def\use@gdlibrary[#1]{\use@@gdlibrary{#1}}
\def\use@@gdlibrary#1{%
  \edef\pgf@list{#1}%
  \pgfutil@for\pgf@temp:=\pgf@list\do{%
    \expandafter\pgfkeys@spdef\expandafter\pgf@temp\expandafter{\pgf@temp}%
    \ifx\pgf@temp\pgfutil@empty
    \else
      \pgfutil@IfFileExists{pgf.gd.\pgf@temp.library.lua}{%
        \directlua{require 'pgf.gd.\pgf@temp.library'}
      }{%
        \pgfutil@IfFileExists{pgf.gd.\pgf@temp.lua}{%
          \directlua{require 'pgf.gd.\pgf@temp'}
        }{%
          \pgfutil@IfFileExists{\pgf@temp.library.lua}{%
            \directlua{require '\pgf@temp.library'}
          }{%
            \directlua{require '\pgf@temp'}
          }}}%
    \fi
  }%
}




%
% Ok, fire up the system by creating the binding!
%
\directlua{
  require 'pgf.gd.interface.InterfaceToDisplay' 
  pgf.gd.interface.InterfaceToDisplay.bind(require 'pgf.gd.bindings.BindingToPGF')
} 



%
% Special setup for keys that are declared by the above libraries, but
% that have a special meaning on the display layer.
%

\pgfkeys{/graph drawing/nodes behind edges/.append code=\csname pgf@gd@nodes@behind@edges#1\endcsname}




\endinput


%
%
% Begin old Stuff
%
%
















%
% Basic Interface to the Graph Drawing Engine
%

% 
% In order to use the graph drawing engine, inside a pgfpicture you
% need to create a graph drawing scope using the following commands;
%

\directlua{require 'pgf.gd.control.TeXInterface'} % deprecated









% Passing options to the graph drawing engine.
% 
% #1 = option's name
% #2 = option's value
% 
% Description:
%
% When a graph drawing algorithm starts working, a set of options,
% called "graph drawing parameters" in the following, can influence the
% way the algorithm works. For instance, an graph drawing parameter
% might be the average distance between vertices which the algorithm
% should take into account. Another example might be the fact the
% certain nodes are special nodes and that a certain edge should have
% a large label.
%
% These graph drawing parameters are different from "usual" pgf
% options: An alogrithmic parameter influenced the way the algorithm
% works, while usual options normally only influence how the result
% looks like. For instance, the fact that a node is red is not an
% graph drawing parameter (usually, at least), while the shape of a node
% might be an graph drawing parameter.
%
% There are three kinds of graph drawing parameters:
%
% 1) graph drawing graph parameters 
%    These parameters influence "the whole graph". An example
%    is the distance between vertices on the same level of a tree. 
%
% 2) graph drawing node parameters
%    These parameters are "attached" to a single node. This includes
%    options that are only meaningful in the context of a graph
%    drawing algorithm (like, say, the "mass" of a node in a
%    force-base algorith), but also hybrid attributed like the shape
%    of a node. The shape is important for pgf when it typesets the
%    node, but it may also be important for the graph drawing
%    algorithm since it might position circles differently from, say,
%    rectangles.
%    
% 3) graph drawing edge parameters
%    Similarly to nodes, edges can also have graph drawing
%    parameters. Also similarly to nodes, there can be purely
%    graph drawing parameters and also options that are hybrid.
%    
% You have to "declare" a graph drawing parameter similarly to a normal
% key, but instead of using the /.code, you use /.graph
% parameter, /.node parameter, and /.edge
% parameter. More details on how these handlers work is given below.
%
% Specifying the set of graph drawing parameters for a given graph or
% node or edge works as follows: When the graph drawing engine is
% started for a graph (using \pgfgdbeginscope), a snapshot is taken of
% all graph drawing graph parameters currently setup at this
% point. Similarly, when a node is created inside such a scope, a
% snapshot is taken of the set of all graph drawing node parameters in
% force at this point is taken and stored together with the
% node. Finally, when an edge is created, a snapshot of the setting of
% the graph drawing edge parameters is taken.
% 
% All of these option sets can easily be accessed inside the graph 
% drawing algorithms, see the documentation of the lua layer.

\def\pgfgdgraphparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/graph parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}
\def\pgfgdnodeparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/node parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}
\def\pgfgdedgeparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/edge parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}

\pgfgdset{
  graph parameters/.initial=,
  node parameters/.initial=,
  edge parameters/.initial=,
}  








% Passing hybrid options
% 
% #1 = option's name
% #2 = option's value
% 
% Description:
%
% Some options, like "sibling distance", can both be considered as
% node options, but also as graph options, in which case they are
% supposed to apply to all nodes of the graph. Such options could, in
% principle, be passed to all nodes, but it much more economic to have
% them defined only once for the whole graph and, then, only store
% deviating values at special nodes.
%
% To facilitate this, you can declare that an option as a hybrid
% node/graph parameter or as a hybrif edge/graph parameter. For such
% parameters, the following happens: Whenever you set the parameter
% outside a graph drawing scope, it will be considered as a graph
% parameter, when you set it inside a graph drawing scope, it will be
% set as a node/edge parameter. This means that when you write, for
% instance, \graph [layered layout, sibling distance=1cm] 
% { a [sibling distance=2cm] -- b -- c }, the first "sibling distance"
% is a graph parameter (the graph drawing scope triggered by "layered
% layout" starts only after all options have been parsed), while the
% second "sibling distance" applies only to node "a".


\def\pgfgdhybridnodegraphparameter#1#2{%
  \ifpgfgdgraphdrawingscopeactive%
    \pgfgdnodeparameter{#1}{#2}%
  \else%
    \pgfgdgraphparameter{#1}{#2}%
  \fi%
}
\def\pgfgdhybridedgegraphparameter#1#2{%
  \ifpgfgdgraphdrawingscopeactive%
    \pgfgdedgeparameter{#1}{#2}%
  \else%
    \pgfgdgraphparameter{#1}{#2}%
  \fi%
}



% Key handler /.graph parameter
% 
% Description:
%
% When this key hanlder is applied to a key, this key becomes a graph
% drawing graph parameter (as explained above). Subsequently, setting
% this key will cause special internals to be setup so that graph
% drawing algorithms can access the value of this key easily and
% directly inside the lua layer.
% 
% A typical usage would be
%
%   /some path/my key/.graph parameter
%  
% Now, when people write /some path/my key=foo in their code, inside
% the algorithm the parameter "my key" would be set to "foo".
% 

\pgfkeys{
  /handlers/.graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdgraphparameter},
  /handlers/.node parameter/.code=\pgf@gd@parameter{#1}{\pgfgdnodeparameter},
  /handlers/.edge parameter/.code=\pgf@gd@parameter{#1}{\pgfgdedgeparameter},
  /handlers/.node or graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdhybridnodegraphparameter},
  /handlers/.edge or graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdhybridedgegraphparameter},
}
\def\pgf@gd@parameter#1#2{%
  \def\pgfgd@temp{#1}%
  \ifx\pgfgd@temp\pgfkeysnovalue@text\PackageError{pgf}{You must specify a parameter type for \pgfkeyscurrentpath}{}\fi%
  \edef\pgf@marshal{\noexpand\pgf@gd@@parameter{\pgfkeyscurrentpath}{\pgfgd@temp}{\noexpand#2}}
  \pgf@marshal%
}

\def\pgf@gd@@parameter#1#2#3{%
  \pgfkeysdef{#1}{
    \pgfkeys{/graph drawing/conversions/#2={##1}}%
    \expandafter\pgf@gd@@@parameter\expandafter{\pgfgdresult}{#3}{#1}%
  }%
}
\def\pgf@gd@@@parameter#1#2#3{#2{#3}{#1}}



% Key handler /.parameter initial
%
% #1 = an initial value
%
% Description:
%
% Use this key handler instead of /.initial to assign an initial value
% to a graph parameter. What will happen is that on the Lua layer, the passed
% value is stored in a special table. Whenever the key is not
% explicitly set by the user, the value #1 will be used.
% 
% Note that
% 
%   /foo/.graph parameter, /foo=5
% 
% and
% 
%   /foo/.graph parameter, /foo/.parameter initial=5
%   
% have the same effect insofar as, in both cases, getOption ('/foo')
% will yield 5. The difference is that in the second case the TeX
% layer does not need to pass around huge lists of options and will,
% thus, be faster. In general, it is recommendable that initial values
% for graph drawing graph parameters are setup using this handler.
% 
% #1 is passed through the conversion of the key before being stored.

\pgfkeys{
  /handlers/.parameter initial/.code={
    {
      % Hack into setting of edge/node/graph parameters
      \let\pgfgdgraphparameter\pgf@gd@steal
      \let\pgfgdnodeparameter\pgf@gd@steal
      \let\pgfgdedgeparameter\pgf@gd@steal
      \expandafter\pgfkeys\expandafter{\pgfkeyscurrentpath={#1}}%
    }
  }
}

\def\pgf@gd@steal#1#2{%
  \directlua{pgf.gd.control.TeXInterface.setParameterDefault('\luaescapestring{#1}',#2)}%
}



% Graph drawing graph parameter "algorithm"
%  
% Description:
% 
% Used to decide which algorithm is used in the graph drawing engine
% for drawing the next graph.

\pgfgdset{
  algorithm/.graph parameter=string,
  layout algorithm/.graph parameter=algorithm,
}











% Helper keys for defining new graph drawing algorithms and their
% options  
% 
% Description:
% 
% When you hanve written a new graph drawing algorithm in lua (see the
% documentation for how this works), you need to make the higher
% levels aware of the algorithm and its parameters.
% 
% In principle, users could just write /graph drawing/algorithm=your
% algorithm's name and set options using for instance /graph
% drawing/your options=foo, but this would result in numerous
% repetitions of the prefix "/graph drawing/" in the code. Indeed, it
% would be somewhat preferable that users can just write things like
% 
% \tikz \graph [planar] { ... };
% 
% and have the option "planar" launch some fancy algorithm. However,
% "planar" will then have to have the path /tikz/graphs/planar, while
% the graph drawing algorithms expect their keys in  /graph drawing.
% 
% To overcome these difficulties, key forwarding is used. You declare
% you keys with the /graph drawing/ path, which is the "correct way"
% of declaring these keys, and then additionally setup keys in the
% /tikz/ and the /tikz/graphs/ paths that forward their values to the
% /graph drawing/ path. The helper functions below are intended to make
% this reasonably easy.
% 
%
% Graph parameters come in too flavours: "common" and
% "family-specific". A "common" graph parameter can be used by
% several graph drawing algorithms. An example are orientation keys,
% which can actually be applied to any graph in a postprocessing
% step. In contrast, "family-specific" keys are only important for
% one algorithm or only for algorithms from a small family of
% algorithms. For instance, a "stiffness" for spring layout algorithms
% would only apply to, well, spring layout algorithms.
% 
% The common graph parameters reside in the path /graph drawing/,
% while the family-specific graph parameters reside in the path /graph
% drawing/<family name>/. For common graph parameters, forwarding will
% be setup in paths like /tikz/ or /tikz/graphs, so you can use these
% keys directly. In contrast, no forwarding will be setup for
% family-specific keys. Rather, these keys can be passed to the
% algorithm's key, which will in turn executed the keys with the
% prefix /graph drawing/<family name>/.


% Declare keys for a new algorithm
% 
% #1 = algorithm's key name
% #2 = algorithm's family name
% #3 = options that configure the algorithm
% 
% Description:
% 
% This will setup the following keys:
% 
% /graph drawing/#1 is setup so that, when executed, the graph drawing
% algorithm is configured by the options in #3 and the value passed to
% are executed as keys with the path prefix /graph
% drawing/#2. This key does nothing by
% default, but it could be used to setup things (as is done in tikz)
% to start the graph drawing engine for the current scope.
% 
% Next, forwarding fill be setup for each path in the current
% forwarding list (set using \pgfgdsetkeyforwardinglist). If <path> is
% in this list, <path>/#1 is forwarded to /graph drawing/#1.
% 
% All keys in #4 are setup with the path prefix #2.
% 
% Note that when several algorithms share keys, they should share the
% family.
%
%
% Example:
%
% \pgfgddeclarealgorithmkey
% {AhrensFKSS2011 minimize crossings}
% {AhrensFKSS2011 minimize crossings}
% {algorithm=localsearchgraph}

\def\pgfgddeclarealgorithmkey#1#2#3{%
  \pgfkeys{
    /graph drawing/#1/.code=\pgfgdset{%
      #3,%
      #2/.cd,%
      ##1,%
      /graph drawing/request scope and layout%
    }
  }%
  \pgf@gd@setup@forwards{#1}
  \pgfutil@g@addto@macro\pgf@gd@forwards@list{\pgf@gd@setup@forwards{#1}}
}





% Declare a new common key
% 
% #1 = an optional path prefix 
% #2 = a list of key declarations
% 
% Description:
% 
% Each <element> of #2 should have the form <key name>/<action>.
% This will cause the following to happen:
% 
% #1/<key name>/<action> is executed
% 
% If #1/<key name> was not defined before, for each <path> in the path
% list, a forward from <path>/<key name> to /graph drawing/<key name>
% is setup.
%
% Example:
%
% \pgfgddeclarekeys{/graph drawing}
% {
%   height/.graph parameter=number,
%   height/.parameter initial=5cm, % no forwarding since already defined.
%   width/.graph parameter=number,
%   width/.parameter initial=5cm,
% }

\def\pgfgddeclareforwardedkeys#1#2{%
  \def\pgf@gd@prefix{#1}%
  \let\pgf@temp\pgfutil@empty
  \foreach \pgf@gd@temp/\pgf@gd@dec in {#2} {%
    \ifx\pgf@gd@temp\pgfutil@empty\else%
    \pgfkeysifdefined{\pgf@gd@prefix/\pgf@gd@temp/.@def}{%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\content%
    \expandafter\expandafter\expandafter{%
    \expandafter\expandafter\expandafter\pgf@gd@parse@onlykey%
    \expandafter\expandafter\expandafter{\expandafter\pgf@gd@temp\expandafter}\expandafter{\pgf@gd@dec}}}{%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\content%
    \expandafter\expandafter\expandafter{%
    \expandafter\expandafter\expandafter\pgf@gd@parse@commonkey%
    \expandafter\expandafter\expandafter{\expandafter\pgf@gd@temp\expandafter}\expandafter{\pgf@gd@dec}}}%
    \expandafter\pgfutil@g@addto@macro\expandafter\pgf@temp\expandafter{\content}%
    \fi
  }
  \pgf@temp
}
\def\pgf@gd@parse@commonkey#1#2{%
  \pgfkeys{\pgf@gd@prefix/#1/#2}
  \pgf@gd@setup@forwards{#1}
  \pgfutil@g@addto@macro\pgf@gd@forwards@list{\pgf@gd@setup@forwards{#1}}
}
\def\pgf@gd@parse@onlykey#1#2{%
  \pgfkeys{\pgf@gd@prefix/#1/#2}
}















%
%
% Collections
%
%

% A collection is a pair consisting of a set of nodes and a set of
% edges. Since the edges need not be between the nodes of the same
% collection, collections are not subgraphs, but something more
% ``loose'' -- namely collections.
%
% Collections are grouped into ``kinds'', that is, all collections
% having the same kind will be grouped together. On the Lua layer, all
% collections of the same kind can be accessed directly via a single
% array; on the \pgfname\ layer, for each kind a separate key is available
% to indicate that a node or an edge belongs to a collection. 
%
% Collections serve two purposes: First, they can be seen as ``hints''
% to graph drawing algorithms that certain nodes and/or edges ``belong
% together''. For instance, collections of kind |same rank| are used
% by the Sugiyama algorithm to group together nodes that should appear
% at the same height of the output. Second, since collections are also
% passed back to the \pgfname\ layer in a postprocessing step, they can be
% used to render complicated concepts such as hyperedges (which are
% just collections of nodes, after all) or subgraphs.



% Declares a new collection kind
%
% #1 = kind
% #2 = layer number
%
% Description:
%
% Declares a new collection kind. This has a number of effects:
%
% First, a key |/graph drawing/|\meta{kind} gets declared and
% key forwarding is setup for this key (so you can also write
% /tikz/\meta{kind}). When this key is used inside a 
% graph drawing scope, all nodes and edges mentioned in the rest of
% the current \TeX\ scope will belong to a new collection whose kind
% is \meta{kind}. This new collection may also have some local
% options, which are specified as an argument to the key. For
% instance, suppose you write
% 
% \pgfgddeclarecollectionkind{hyper}{1}
% 
% \graph {
%   a, b, c, d;
%   { [hyper={foo=bar}] a, b, c }
%   { [hyper={red,green}] b, c, d }
% };
% 
% In this case, the nodes |a|, |b|, |c| will belong to a collection of
% kind |hyper| and this collection will have the option |foo=bar|
% set. The nodes |b|, |c|, and |d| will (also) belong to another
% collection of the same kind |hyper|, but with the options |red| and
% |green| set.
% 
% The options passed to the key are exectued with the path prefix
% |/graph drawing|. The options must all be graph parameters, node
% parameters, or edge parameters.
% 
% Normally, as claimed above, using the key will cause a new
% collection to be started inside the current \TeX\ group. However,
% this is not quite true: You can use the key |/graph drawing/name|
% inside the options passed to the key. In this case, if a collection
% of the same name has already been specified earlier (in some other
% group), the following nodes and edges get added to this earlier
% collection:
%
% \graph {
%   a, b, c, d;
%   { [hyper={name=core}] a, b }
%   { [hyper] b, c, d }
%   { [hyper={name=core}] d }
% };
% 
% In the above example, the collection |core| will be of kind |hyper|
% and will contain the nodes |a|, |b|, and |d|. A second (unnamed)
% collection of kind |hyper| will contain the nodes |b|, |c|, and
% |d|. Internally, unnamed collections get assigned a unique internal
% name.
% 
% Let us next have a look at the further effects declaring a
% collection kind has: On the Lua layer, when the graph drawing engine
% gets warmed up, the collections of the input graph get ``sorted out''
% according to their kinds. In detail, the representation of the graph
% drawing scope has a table |collections| that has an entry for each
% collection \meta{kind}. (In case \meta{kind} contains a space or
% other strange characters, you have to access the |collections| table
% through a string index. For instance, to access the |same rank|
% collections, use |collections['same rank']|.)
% 
% Each entry of the |collections| table is an array in which the
% collections of a certain kind are stored in the order they appear in
% the input. Each of these collections is itself a table, having the
% following fields: The |name| field contains the collection's name,
% either the one passed using the |name| key or the internal name
% created automatically. The |vertices| and |edges| fields each
% contain arrays of all objects being part of the collection.
%
% 
% Once a graph drawing algorithms has computed node and edge
% placements, the binding layer will attempt to ``render'' all
% collections: For this, for each collection kind, the key
% |/graph drawing/|\meta{kind}|/begin rendering| is tried once. Next, |/graph
% drawing/|\meta{kind}|/render| is tried once for each
% collection. Each time, the values stored in the |generated_options|
% table of the collection (if present) is passed to the |render|
% key. Finally, |/graph drawing/|\meta{kind}|/end rendering| is tried.
% 
% The idea of the above is that you can setup certain collection kinds
% to be rendered in a special way. Suppose, for instance, you would
% like hyperedges to be rendered. In this case, a graph drawing
% algorithm should iterate over all collections of type |hyper| and
% compute some hints on how to render the hyperedge and store this
% information in the |generated_options| table of the hyperedge. Then,
% the key |/graph drawing/hyper/render| should be setup so that it
% contains some code that is able to read key--value pairs passed to
% it (which are the key--value pairs of the |generated_options| table)
% and use this information to nicely draw the hyperedge.
% 
% The last parameter, the layer number, is used to specify the order
% in which the different collection kinds are rendered. The higher the
% number, the later the collection will be rendered. Thus, if there is
% a collection kind with layer number 10 and another with layer number
% 20, all collections of the first kind will be rendered first,
% followed by all collections of the second kind.
% 
% Collections whose layer kinds are non-negative get rendered
% \emph{after} the nodes and edges have already been rendered. In
% contrast, collections with a negative layer number get shown
% ``below'' the nodes and edges. Actually, they are also rendered
% after the nodes and edges have already been drawn, but they are a
% put in a box that is shipped out before the the box of the nodes and
% edges gets shipped out.
% 

\def\pgfgddeclarecollectionkind#1#2{
  \pgfgddeclareforwardedkeys{/graph drawing}{#1/.code=}
  \pgfgdset{#1/.append code=\pgf@gd@handle@collection{#1}{##1}}
  \directlua{pgf.gd.control.TeXInterface.addCollectionKind('\luaescapestring{#1}',#2)}
}

\def\pgf@gd@handle@collection#1#2{%
  {%
    % Reset options
    \let\pgf@gd@collection@name=\pgfutil@empty%
    \pgfkeyssetvalue{/graph drawing/graph parameters}{}%
    \pgfkeyssetvalue{/graph drawing/edge parameters}{}%
    \pgfkeyssetvalue{/graph drawing/node parameters}{}%
    \pgfgdset{#2}%
    \pgfkeysgetvalue{/graph drawing/graph parameters}\pgf@gd@gp@temp\global\let\pgf@gd@gp@temp\pgf@gd@gp@temp
    \pgfkeysgetvalue{/graph drawing/edge parameters}\pgf@gd@ep@temp\global\let\pgf@gd@ep@temp\pgf@gd@ep@temp
    \pgfkeysgetvalue{/graph drawing/node parameters}\pgf@gd@np@temp\global\let\pgf@gd@np@temp\pgf@gd@np@temp
    \global\let\pgfgdlastcollectionname\pgf@gd@collection@name
  }%
  \ifx\pgfgdlastcollectionname\pgfutil@empty%
    \edef\pgfgdlastcollectionname{collectionPGFINTERNAL\the\pgf@gd@collectioncount}%
    \global\advance\pgf@gd@collectioncount by 1\relax
  \fi%
  \pgf@gd@handle@collection@set{#1}{\pgfgdlastcollectionname}{\pgf@gd@gp@temp\pgf@gd@ep@temp\pgf@gd@np@temp}
}

\def\pgf@gd@handle@collection@set#1#2#3{%
  \edef\pgf@temp{{/graph drawing/collection memberships}{{kind='\luaescapestring{#1}',name='\luaescapestring{#2}',options={#3}}}}%
  \expandafter\pgfgdnodeparameter\pgf@temp
  \expandafter\pgfgdedgeparameter\pgf@temp
}

\pgfgdset{name/.store in=\pgf@gd@collection@name}

\newcount\pgf@gd@collectioncount






\endinput